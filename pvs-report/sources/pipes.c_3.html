<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pipes.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &quot;pipes.h&quot;</a>
<a name="ln5">#include &lt;stdint.h&gt;</a>
<a name="ln6">#include &lt;stddef.h&gt;</a>
<a name="ln7">#include &quot;memory.h&quot;</a>
<a name="ln8">#include &quot;panic.h&quot;</a>
<a name="ln9">#include &quot;process.h&quot;</a>
<a name="ln10">#include &quot;scheduler.h&quot;</a>
<a name="ln11">#include &quot;lib.h&quot;</a>
<a name="ln12">#include &quot;semaphores.h&quot;</a>
<a name="ln13">#include &quot;strings.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15">#define FALSE 0</a>
<a name="ln16">#define TRUE !FALSE</a>
<a name="ln17">#define NEXT_IDX(i) (((i) + 1) % PIPE_BUFFER_SIZE)</a>
<a name="ln18"> </a>
<a name="ln19">struct pipeCDT {</a>
<a name="ln20">    int id;</a>
<a name="ln21">    int readIndex;</a>
<a name="ln22">    int writeIndex;</a>
<a name="ln23">    uint8_t buffer[PIPE_BUFFER_SIZE];</a>
<a name="ln24">    semADT readSem;</a>
<a name="ln25">    semADT writeSem;</a>
<a name="ln26">    int refCount;</a>
<a name="ln27">    int closed;</a>
<a name="ln28">    uint8_t lock;</a>
<a name="ln29">    int activeOps;</a>
<a name="ln30">    int readerCount;</a>
<a name="ln31">    int writerCount;</a>
<a name="ln32">};</a>
<a name="ln33"> </a>
<a name="ln34">static pipeADT * pipes = NULL;</a>
<a name="ln35">static int pipeSerial = 0;</a>
<a name="ln36"> </a>
<a name="ln37">// used a static buffer to avoid dynamic allocation in getSemName</a>
<a name="ln38">static char semNameBuffer[16];</a>
<a name="ln39">static char * getSemName(int serial, char mode) {</a>
<a name="ln40">    semNameBuffer[4] = '0' + ((serial / 10) % 10);</a>
<a name="ln41">    semNameBuffer[5] = '0' + (serial % 10);</a>
<a name="ln42">    semNameBuffer[6] = mode;</a>
<a name="ln43">    return semNameBuffer;</a>
<a name="ln44">}</a>
<a name="ln45"> </a>
<a name="ln46">void initPipes() {</a>
<a name="ln47">    pipes = myMalloc(sizeof(pipeADT) * MAX_PIPES);</a>
<a name="ln48">    if(pipes == NULL){</a>
<a name="ln49">        panic(&quot;Failed to allocate memory for pipes&quot;);</a>
<a name="ln50">    }</a>
<a name="ln51"> </a>
<a name="ln52">    pipeSerial = 0;</a>
<a name="ln53">    strcpy(semNameBuffer, &quot;pipeXXY&quot;);</a>
<a name="ln54">    semNameBuffer[7] = '\0';</a>
<a name="ln55">    for (int i = 0; i &lt; MAX_PIPES; i++) {</a>
<a name="ln56">        pipes[i] = NULL;</a>
<a name="ln57">    }</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">static void freePipe(pipeADT pipe) {</a>
<a name="ln61">    if (pipe == NULL) {</a>
<a name="ln62">        return;</a>
<a name="ln63">    }</a>
<a name="ln64">    semDestroy(pipe-&gt;readSem);</a>
<a name="ln65">    semDestroy(pipe-&gt;writeSem);</a>
<a name="ln66">    myFree(pipe);</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">static pipeADT buildPipe(int slot, int serial) {</a>
<a name="ln70">    pipeADT newPipe = myMalloc(sizeof(struct pipeCDT));</a>
<a name="ln71">    if(newPipe == NULL){</a>
<a name="ln72">        return NULL;</a>
<a name="ln73">    }</a>
<a name="ln74"> </a>
<a name="ln75">    newPipe-&gt;id = slot;</a>
<a name="ln76">    newPipe-&gt;readIndex = 0;</a>
<a name="ln77">   newPipe-&gt;writeIndex = 0;</a>
<a name="ln78">    newPipe-&gt;refCount = 0;</a>
<a name="ln79">    newPipe-&gt;closed = 0;</a>
<a name="ln80">    newPipe-&gt;lock = 0;</a>
<a name="ln81">    newPipe-&gt;activeOps = 0;</a>
<a name="ln82">    newPipe-&gt;readerCount = 0;</a>
<a name="ln83">    newPipe-&gt;writerCount = 0;</a>
<a name="ln84"> </a>
<a name="ln85">    // Initialize semaphores</a>
<a name="ln86">    getSemName(serial, 'R');</a>
<a name="ln87">    newPipe-&gt;readSem = semInit(semNameBuffer, 0);</a>
<a name="ln88">    if(newPipe-&gt;readSem == NULL){</a>
<a name="ln89">        myFree(newPipe);</a>
<a name="ln90">        return NULL;</a>
<a name="ln91">    }</a>
<a name="ln92">    getSemName(serial, 'W');</a>
<a name="ln93">    newPipe-&gt;writeSem = semInit(semNameBuffer, PIPE_BUFFER_SIZE);</a>
<a name="ln94">    if(newPipe-&gt;writeSem == NULL){</a>
<a name="ln95">        semDestroy(newPipe-&gt;readSem);</a>
<a name="ln96">        newPipe-&gt;readSem = NULL;</a>
<a name="ln97">        myFree(newPipe);</a>
<a name="ln98">        return NULL;</a>
<a name="ln99">    }</a>
<a name="ln100">    return newPipe;</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">int openPipe() {</a>
<a name="ln104">    int slot = -1;</a>
<a name="ln105">    for (int i = 0; i &lt; MAX_PIPES; i++) {</a>
<a name="ln106">        if (pipes[i] == NULL) {</a>
<a name="ln107">            slot = i;</a>
<a name="ln108">            break;</a>
<a name="ln109">        }</a>
<a name="ln110">    }</a>
<a name="ln111">    if (slot == -1) {</a>
<a name="ln112">        return -1;</a>
<a name="ln113">    }</a>
<a name="ln114"> </a>
<a name="ln115">    int serial = pipeSerial;</a>
<a name="ln116">    pipeADT pipe = buildPipe(slot, serial);</a>
<a name="ln117">    if(pipe == NULL){</a>
<a name="ln118">        return -1;</a>
<a name="ln119">    }</a>
<a name="ln120">    pipeSerial++;</a>
<a name="ln121">    pipes[slot] = pipe;</a>
<a name="ln122">    return pipe-&gt;id;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">static pipeADT getPipe(int pipeID) {</a>
<a name="ln126">    if (pipeID &lt; 0 || pipeID &gt;= MAX_PIPES) {</a>
<a name="ln127">        return NULL;</a>
<a name="ln128">    }</a>
<a name="ln129">    return pipes[pipeID];</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">static void tryFinalizePipe(int pipeID) {</a>
<a name="ln133">    pipeADT pipe = getPipe(pipeID);</a>
<a name="ln134">    if (pipe == NULL) {</a>
<a name="ln135">        return;</a>
<a name="ln136">    }</a>
<a name="ln137">    semLock(&amp;pipe-&gt;lock);</a>
<a name="ln138">    int shouldFinalize = pipe-&gt;closed &amp;&amp; pipe-&gt;refCount == 0 &amp;&amp; pipe-&gt;activeOps == 0;</a>
<a name="ln139">    if (!shouldFinalize) {</a>
<a name="ln140">        semUnlock(&amp;pipe-&gt;lock);</a>
<a name="ln141">        return;</a>
<a name="ln142">    }</a>
<a name="ln143">    pipes[pipe-&gt;id] = NULL;</a>
<a name="ln144">    semUnlock(&amp;pipe-&gt;lock);</a>
<a name="ln145"> </a>
<a name="ln146">    freePipe(pipe);</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">static void pipeEnterOperation(pipeADT pipe) {</a>
<a name="ln150">    semLock(&amp;pipe-&gt;lock);</a>
<a name="ln151">    pipe-&gt;activeOps++;</a>
<a name="ln152">    semUnlock(&amp;pipe-&gt;lock);</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">static void pipeLeaveOperation(pipeADT pipe) {</a>
<a name="ln156">    semLock(&amp;pipe-&gt;lock);</a>
<a name="ln157">    pipe-&gt;activeOps--;</a>
<a name="ln158">    semUnlock(&amp;pipe-&gt;lock);</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163">static int closePipeInternal(pipeADT pipe, PipeEndpointRole role) {</a>
<a name="ln164">    if (pipe == NULL) {</a>
<a name="ln165">        return -1;</a>
<a name="ln166">    }</a>
<a name="ln167"> </a>
<a name="ln168">    int wakeReaders = FALSE;</a>
<a name="ln169">    int wakeWriters = FALSE;</a>
<a name="ln170">    int remainingRefs;</a>
<a name="ln171"> </a>
<a name="ln172">    semLock(&amp;pipe-&gt;lock);</a>
<a name="ln173"> </a>
<a name="ln174">    if (pipe-&gt;refCount &gt; 0) {</a>
<a name="ln175">        pipe-&gt;refCount--;</a>
<a name="ln176">    }</a>
<a name="ln177"> </a>
<a name="ln178">    if (role == PIPE_ROLE_READER || role == PIPE_ROLE_NONE) {</a>
<a name="ln179">        if (pipe-&gt;readerCount &gt; 0) {</a>
<a name="ln180">            pipe-&gt;readerCount--;</a>
<a name="ln181">        }</a>
<a name="ln182">    }</a>
<a name="ln183"> </a>
<a name="ln184">    if (role == PIPE_ROLE_WRITER || role == PIPE_ROLE_NONE) {</a>
<a name="ln185">        if (pipe-&gt;writerCount &gt; 0) {</a>
<a name="ln186">            pipe-&gt;writerCount--;</a>
<a name="ln187">            if (pipe-&gt;writerCount == 0) {</a>
<a name="ln188">                if (!pipe-&gt;closed) {</a>
<a name="ln189">                    pipe-&gt;closed = TRUE;</a>
<a name="ln190">                }</a>
<a name="ln191">                wakeReaders = TRUE;</a>
<a name="ln192">            }</a>
<a name="ln193">        }</a>
<a name="ln194">    }</a>
<a name="ln195"> </a>
<a name="ln196">    remainingRefs = pipe-&gt;refCount;</a>
<a name="ln197"> </a>
<a name="ln198">    if (remainingRefs == 0) {</a>
<a name="ln199">        if (!pipe-&gt;closed) {</a>
<a name="ln200">            pipe-&gt;closed = TRUE;</a>
<a name="ln201">        }</a>
<a name="ln202">        wakeReaders = TRUE;</a>
<a name="ln203">        wakeWriters = TRUE;</a>
<a name="ln204">    }</a>
<a name="ln205"> </a>
<a name="ln206">    semUnlock(&amp;pipe-&gt;lock);</a>
<a name="ln207"> </a>
<a name="ln208">    if (wakeReaders) {</a>
<a name="ln209">        wakeBlocked(pipe-&gt;readSem);</a>
<a name="ln210">    }</a>
<a name="ln211">    if (wakeWriters) {</a>
<a name="ln212">        wakeBlocked(pipe-&gt;writeSem);</a>
<a name="ln213">    }</a>
<a name="ln214"> </a>
<a name="ln215">    if (remainingRefs &gt; 0) {</a>
<a name="ln216">        return 0;</a>
<a name="ln217">    }</a>
<a name="ln218"> </a>
<a name="ln219">    tryFinalizePipe(pipe-&gt;id);</a>
<a name="ln220">    return 0;</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">int closePipe(int pipeID) {</a>
<a name="ln224">    pipeADT pipe = getPipe(pipeID);</a>
<a name="ln225">    if (pipe == NULL) {</a>
<a name="ln226">        return -1;</a>
<a name="ln227">    }</a>
<a name="ln228"> </a>
<a name="ln229">    return closePipeInternal(pipe, PIPE_ROLE_NONE);</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">static int pipeHasData(pipeADT pipe) {</a>
<a name="ln233">    return pipe-&gt;readIndex != pipe-&gt;writeIndex;</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">int readPipe(int pipeID, uint8_t * buffer, int size) {</a>
<a name="ln237">    pipeADT pipe = getPipe(pipeID);</a>
<a name="ln238">    if (pipe == NULL || buffer == NULL || size &lt; 0) {</a>
<a name="ln239">        return -1;</a>
<a name="ln240">    }</a>
<a name="ln241"> </a>
<a name="ln242">    if (size == 0) {</a>
<a name="ln243">        return 0;</a>
<a name="ln244">    }</a>
<a name="ln245"> </a>
<a name="ln246">    pipeEnterOperation(pipe);</a>
<a name="ln247">    int bytesRead = 0;</a>
<a name="ln248"> </a>
<a name="ln249">    while (bytesRead &lt; size) {</a>
<a name="ln250">        if (pipe-&gt;closed &amp;&amp; !pipeHasData(pipe)) {</a>
<a name="ln251">            break;</a>
<a name="ln252">        }</a>
<a name="ln253"> </a>
<a name="ln254">        if (wait(pipe-&gt;readSem) != 0) {</a>
<a name="ln255">            break;</a>
<a name="ln256">        }</a>
<a name="ln257"> </a>
<a name="ln258">        semLock(&amp;pipe-&gt;lock);</a>
<a name="ln259"> </a>
<a name="ln260">        if (!pipeHasData(pipe)) {</a>
<a name="ln261">            int writersRemaining = pipe-&gt;writerCount;</a>
<a name="ln262">            semUnlock(&amp;pipe-&gt;lock);</a>
<a name="ln263">            if (pipe-&gt;closed || writersRemaining == 0) {</a>
<a name="ln264">                break;</a>
<a name="ln265">            }</a>
<a name="ln266">            continue;</a>
<a name="ln267">        }</a>
<a name="ln268"> </a>
<a name="ln269">        buffer[bytesRead] = pipe-&gt;buffer[pipe-&gt;readIndex];</a>
<a name="ln270">        pipe-&gt;readIndex = NEXT_IDX(pipe-&gt;readIndex);</a>
<a name="ln271">        semUnlock(&amp;pipe-&gt;lock);</a>
<a name="ln272"> </a>
<a name="ln273">        if (post(pipe-&gt;writeSem) != 0) {</a>
<a name="ln274">            panic(&quot;Pipe write semaphore failed&quot;);</a>
<a name="ln275">        }</a>
<a name="ln276"> </a>
<a name="ln277">        bytesRead++;</a>
<a name="ln278">    }</a>
<a name="ln279"> </a>
<a name="ln280">    pipeLeaveOperation(pipe);</a>
<a name="ln281">    tryFinalizePipe(pipeID);</a>
<a name="ln282">    return bytesRead;</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">int writePipe(int pipeID, uint8_t * buffer, int size) {</a>
<a name="ln286">    pipeADT pipe = getPipe(pipeID);</a>
<a name="ln287">    if (pipe == NULL || buffer == NULL || size &lt; 0){</a>
<a name="ln288">        return -1;</a>
<a name="ln289">    }</a>
<a name="ln290">    if (pipe-&gt;closed){</a>
<a name="ln291">        return -1;</a>
<a name="ln292">    }</a>
<a name="ln293">    if (size == 0) {</a>
<a name="ln294">        return 0;</a>
<a name="ln295">    }</a>
<a name="ln296"> </a>
<a name="ln297">    pipeEnterOperation(pipe);</a>
<a name="ln298">    int written = 0;</a>
<a name="ln299"> </a>
<a name="ln300">    while (written &lt; size) {</a>
<a name="ln301">        if (pipe-&gt;closed) {</a>
<a name="ln302">            break;</a>
<a name="ln303">        }</a>
<a name="ln304"> </a>
<a name="ln305">        if (wait(pipe-&gt;writeSem) != 0) {</a>
<a name="ln306">            break;</a>
<a name="ln307">        }</a>
<a name="ln308"> </a>
<a name="ln309">        if (pipe-&gt;closed) {</a>
<a name="ln310">            post(pipe-&gt;writeSem);</a>
<a name="ln311">            break;</a>
<a name="ln312">        }</a>
<a name="ln313"> </a>
<a name="ln314">        semLock(&amp;pipe-&gt;lock);</a>
<a name="ln315">        pipe-&gt;buffer[pipe-&gt;writeIndex] = buffer[written];</a>
<a name="ln316">        pipe-&gt;writeIndex = NEXT_IDX(pipe-&gt;writeIndex);</a>
<a name="ln317">        semUnlock(&amp;pipe-&gt;lock);</a>
<a name="ln318"> </a>
<a name="ln319">        if (post(pipe-&gt;readSem) != 0) {</a>
<a name="ln320">            panic(&quot;Pipe read semaphore failed&quot;);</a>
<a name="ln321">        }</a>
<a name="ln322"> </a>
<a name="ln323">        written++;</a>
<a name="ln324">    }</a>
<a name="ln325"> </a>
<a name="ln326">    pipeLeaveOperation(pipe);</a>
<a name="ln327">    tryFinalizePipe(pipeID);</a>
<a name="ln328">    return written;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">int pipeRetain(int pipeID, PipeEndpointRole role) {</a>
<a name="ln332">    pipeADT pipe = getPipe(pipeID);</a>
<a name="ln333">    if (pipe == NULL) {</a>
<a name="ln334">        return -1;</a>
<a name="ln335">    }</a>
<a name="ln336"> </a>
<a name="ln337">    if (role != PIPE_ROLE_READER &amp;&amp; role != PIPE_ROLE_WRITER) {</a>
<a name="ln338">        return -1;</a>
<a name="ln339">    }</a>
<a name="ln340"> </a>
<a name="ln341">    semLock(&amp;pipe-&gt;lock);</a>
<a name="ln342">    if (role == PIPE_ROLE_WRITER) {</a>
<a name="ln343">        if (pipe-&gt;closed) {</a>
<a name="ln344">            if (pipe-&gt;writerCount == 0) {</a>
<a name="ln345">                pipe-&gt;closed = FALSE;</a>
<a name="ln346">            } else {</a>
<a name="ln347">                semUnlock(&amp;pipe-&gt;lock);</a>
<a name="ln348">                return -1;</a>
<a name="ln349">            }</a>
<a name="ln350">        }</a>
<a name="ln351">        pipe-&gt;writerCount++;</a>
<a name="ln352">    } else {</a>
<a name="ln353">        pipe-&gt;readerCount++;</a>
<a name="ln354">    }</a>
<a name="ln355"> </a>
<a name="ln356">    pipe-&gt;refCount++;</a>
<a name="ln357">    semUnlock(&amp;pipe-&gt;lock);</a>
<a name="ln358">    return 0;</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">int pipeRelease(int pipeID, PipeEndpointRole role) {</a>
<a name="ln362">    pipeADT pipe = getPipe(pipeID);</a>
<a name="ln363">    if (pipe == NULL) {</a>
<a name="ln364">        return -1;</a>
<a name="ln365">    }</a>
<a name="ln366"> </a>
<a name="ln367">    return closePipeInternal(pipe, role);</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">void pipeResetEndpoints(PipeEndpoint endpoints[PIPE_FD_COUNT]) {</a>
<a name="ln371">    if (endpoints == NULL) {</a>
<a name="ln372">        return;</a>
<a name="ln373">    }</a>
<a name="ln374"> </a>
<a name="ln375">    for (int i = 0; i &lt; PIPE_FD_COUNT; i++) {</a>
<a name="ln376">        endpoints[i].type = PIPE_ENDPOINT_CONSOLE;</a>
<a name="ln377">        endpoints[i].pipeID = -1;</a>
<a name="ln378">        endpoints[i].role = PIPE_ROLE_NONE;</a>
<a name="ln379">    }</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">static int pipeSetEndpoint(PipeEndpoint *endpoint, PipeEndpointRole role, PipeEndpointType type, int pipeID) {</a>
<a name="ln383">    if (endpoint == NULL) {</a>
<a name="ln384">        return -1;</a>
<a name="ln385">    }</a>
<a name="ln386"> </a>
<a name="ln387">    if (endpoint-&gt;type == PIPE_ENDPOINT_PIPE &amp;&amp; endpoint-&gt;pipeID &gt;= 0) {</a>
<a name="ln388">        pipeRelease(endpoint-&gt;pipeID, endpoint-&gt;role);</a>
<a name="ln389">    }</a>
<a name="ln390"> </a>
<a name="ln391">    endpoint-&gt;type = PIPE_ENDPOINT_NONE;</a>
<a name="ln392">    endpoint-&gt;pipeID = -1;</a>
<a name="ln393">    endpoint-&gt;role = PIPE_ROLE_NONE;</a>
<a name="ln394"> </a>
<a name="ln395">    switch (type) {</a>
<a name="ln396">        case PIPE_ENDPOINT_NONE:</a>
<a name="ln397">            return 0;</a>
<a name="ln398">        case PIPE_ENDPOINT_CONSOLE:</a>
<a name="ln399">            endpoint-&gt;type = PIPE_ENDPOINT_CONSOLE;</a>
<a name="ln400">            return 0;</a>
<a name="ln401">        case PIPE_ENDPOINT_PIPE:</a>
<a name="ln402">            if (role == PIPE_ROLE_NONE) {</a>
<a name="ln403">                return -1;</a>
<a name="ln404">            }</a>
<a name="ln405">            if (pipeRetain(pipeID, role) != 0) {</a>
<a name="ln406">                return -1;</a>
<a name="ln407">            }</a>
<a name="ln408">            endpoint-&gt;type = PIPE_ENDPOINT_PIPE;</a>
<a name="ln409">            endpoint-&gt;pipeID = pipeID;</a>
<a name="ln410">            endpoint-&gt;role = role;</a>
<a name="ln411">            return 0;</a>
<a name="ln412">        default:</a>
<a name="ln413">            return -1;</a>
<a name="ln414">    }</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">int pipeSetReadTarget(PipeEndpoint endpoints[PIPE_FD_COUNT], PipeEndpointType type, int pipeID) {</a>
<a name="ln418">    if (endpoints == NULL) {</a>
<a name="ln419">        return -1;</a>
<a name="ln420">    }</a>
<a name="ln421">    return pipeSetEndpoint(&amp;endpoints[READ_FD], PIPE_ROLE_READER, type, pipeID);</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">int pipeSetWriteTarget(PipeEndpoint endpoints[PIPE_FD_COUNT], PipeEndpointType type, int pipeID) {</a>
<a name="ln425">    if (endpoints == NULL) {</a>
<a name="ln426">        return -1;</a>
<a name="ln427">    }</a>
<a name="ln428">    return pipeSetEndpoint(&amp;endpoints[WRITE_FD], PIPE_ROLE_WRITER, type, pipeID);</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">int pipeReadEndpoint(PipeEndpoint *endpoint, uint8_t *buffer, int size) {</a>
<a name="ln432">    if (endpoint == NULL) {</a>
<a name="ln433">        return -1;</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">    if (endpoint-&gt;type != PIPE_ENDPOINT_PIPE) {</a>
<a name="ln437">        return -1;</a>
<a name="ln438">    }</a>
<a name="ln439"> </a>
<a name="ln440">    return readPipe(endpoint-&gt;pipeID, buffer, size);</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">int pipeWriteEndpoint(PipeEndpoint *endpoint, const uint8_t *buffer, int size) {</a>
<a name="ln444">    if (endpoint == NULL) {</a>
<a name="ln445">        return -1;</a>
<a name="ln446">    }</a>
<a name="ln447"> </a>
<a name="ln448">    if (endpoint-&gt;type != PIPE_ENDPOINT_PIPE) {</a>
<a name="ln449">        return -1;</a>
<a name="ln450">    }</a>
<a name="ln451"> </a>
<a name="ln452">    // cast away const to reuse writePipe signature</a>
<a name="ln453">    return writePipe(endpoint-&gt;pipeID, (uint8_t *)buffer, size);</a>
<a name="ln454">}</a>
</code></pre>
<div class="balloon" rel="309"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'pipe-&gt;closed' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>