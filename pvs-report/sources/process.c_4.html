<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>process.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &quot;process.h&quot;</a>
<a name="ln5">#include &lt;lib.h&gt;</a>
<a name="ln6">#include &quot;memory.h&quot;</a>
<a name="ln7">#include &quot;panic.h&quot;</a>
<a name="ln8">#include &lt;string.h&gt;</a>
<a name="ln9">#include &quot;scheduler.h&quot;</a>
<a name="ln10">#include &quot;interrupts.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12"> </a>
<a name="ln13">typedef struct pcb_table {</a>
<a name="ln14">    Process * processes[MAX_PROCESSES];</a>
<a name="ln15">    int processesCount;</a>
<a name="ln16">    int current_pid;</a>
<a name="ln17">    int foreground_pid;</a>
<a name="ln18">} pcb_table;</a>
<a name="ln19"> </a>
<a name="ln20">static pcb_table * PCBTable = NULL;</a>
<a name="ln21"> </a>
<a name="ln22">static Process *terminatedQueue[MAX_PROCESSES];</a>
<a name="ln23">static int terminatedCount = 0;</a>
<a name="ln24">static void * init_shell_entry = NULL;</a>
<a name="ln25">static int initProcessMain(void);</a>
<a name="ln26">static void cleanupProcessEndpoints(Process *process);</a>
<a name="ln27">static int initProcessEndpoints(Process *process, Process *parent);</a>
<a name="ln28"> </a>
<a name="ln29">static int cmpInt(void *a, void *b) {</a>
<a name="ln30">    return *((int *)a) - *((int *)b);</a>
<a name="ln31">}</a>
<a name="ln32"> </a>
<a name="ln33">static void initProcessSem(Process *process) {</a>
<a name="ln34">    char semName[16] = &quot;process&quot;;</a>
<a name="ln35">	semName[7] = '0' + process-&gt;pid / 100;</a>
<a name="ln36">	semName[8] = '0' + process-&gt;pid / 10;</a>
<a name="ln37">	semName[9] = '0' + process-&gt;pid % 10;</a>
<a name="ln38">	semName[10] = '\0';</a>
<a name="ln39">	process-&gt;wait_sem = semInit(semName, 0);</a>
<a name="ln40">}</a>
<a name="ln41"> </a>
<a name="ln42">static void cleanupProcessEndpoints(Process *process) {</a>
<a name="ln43">    if (process == NULL) {</a>
<a name="ln44">        return;</a>
<a name="ln45">    }</a>
<a name="ln46"> </a>
<a name="ln47">    for (int i = 0; i &lt; PIPE_FD_COUNT; i++) {</a>
<a name="ln48">        PipeEndpoint *endpoint = &amp;process-&gt;fds[i];</a>
<a name="ln49">        if (endpoint-&gt;type == PIPE_ENDPOINT_PIPE &amp;&amp; endpoint-&gt;pipeID &gt;= 0) {</a>
<a name="ln50">            pipeRelease(endpoint-&gt;pipeID, endpoint-&gt;role);</a>
<a name="ln51">            endpoint-&gt;role = PIPE_ROLE_NONE;</a>
<a name="ln52">        }</a>
<a name="ln53">    }</a>
<a name="ln54"> </a>
<a name="ln55">    pipeResetEndpoints(process-&gt;fds);</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">static int initProcessEndpoints(Process *process, Process *parent) {</a>
<a name="ln59">    if (process == NULL) {</a>
<a name="ln60">        return -1;</a>
<a name="ln61">    }</a>
<a name="ln62"> </a>
<a name="ln63">    pipeResetEndpoints(process-&gt;fds);</a>
<a name="ln64"> </a>
<a name="ln65">    if (parent == NULL) {</a>
<a name="ln66">        return 0;</a>
<a name="ln67">    }</a>
<a name="ln68"> </a>
<a name="ln69">    for (int fd = 0; fd &lt; PIPE_FD_COUNT; fd++) {</a>
<a name="ln70">        PipeEndpointType type = parent-&gt;fds[fd].type;</a>
<a name="ln71">        int pipeID = parent-&gt;fds[fd].pipeID;</a>
<a name="ln72">        int status;</a>
<a name="ln73">        if (fd == READ_FD) {</a>
<a name="ln74">            status = pipeSetReadTarget(process-&gt;fds, type, pipeID);</a>
<a name="ln75">        } else {</a>
<a name="ln76">            status = pipeSetWriteTarget(process-&gt;fds, type, pipeID);</a>
<a name="ln77">        }</a>
<a name="ln78">        if (status != 0) {</a>
<a name="ln79">            cleanupProcessEndpoints(process);</a>
<a name="ln80">            return -1;</a>
<a name="ln81">        }</a>
<a name="ln82">    }</a>
<a name="ln83"> </a>
<a name="ln84">    return 0;</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87">static void enqueueTerminatedProcess(Process *process) {</a>
<a name="ln88">    if (process == NULL) {</a>
<a name="ln89">        return;</a>
<a name="ln90">    }</a>
<a name="ln91"> </a>
<a name="ln92">    for (int i = 0; i &lt; terminatedCount; i++) {</a>
<a name="ln93">        if (terminatedQueue[i] == process) {</a>
<a name="ln94">            return;</a>
<a name="ln95">        }</a>
<a name="ln96">    }</a>
<a name="ln97"> </a>
<a name="ln98">    if (terminatedCount &gt;= MAX_PROCESSES) {</a>
<a name="ln99">        panic(&quot;Terminated process queue overflow&quot;);</a>
<a name="ln100">    }</a>
<a name="ln101"> </a>
<a name="ln102">    terminatedQueue[terminatedCount++] = process;</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">void processCleanupTerminated(Process *exclude) {</a>
<a name="ln106">    if (terminatedCount == 0) {</a>
<a name="ln107">        return;</a>
<a name="ln108">    }</a>
<a name="ln109"> </a>
<a name="ln110">    int writeIndex = 0;</a>
<a name="ln111"> </a>
<a name="ln112">    for (int i = 0; i &lt; terminatedCount; i++) {</a>
<a name="ln113">        Process *process = terminatedQueue[i];</a>
<a name="ln114">        if (process == NULL) {</a>
<a name="ln115">            continue;</a>
<a name="ln116">        }</a>
<a name="ln117"> </a>
<a name="ln118">        if (process == exclude) {</a>
<a name="ln119">            terminatedQueue[writeIndex++] = process;</a>
<a name="ln120">            continue;</a>
<a name="ln121">        }</a>
<a name="ln122"> </a>
<a name="ln123">        removeProcess(process);</a>
<a name="ln124">    }</a>
<a name="ln125"> </a>
<a name="ln126">    for (int i = writeIndex; i &lt; terminatedCount; i++) {</a>
<a name="ln127">        terminatedQueue[i] = NULL;</a>
<a name="ln128">    }</a>
<a name="ln129"> </a>
<a name="ln130">    terminatedCount = writeIndex;</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">int initPCBTable() {</a>
<a name="ln134">    PCBTable = myMalloc(sizeof(pcb_table));</a>
<a name="ln135">    if (PCBTable == NULL) {</a>
<a name="ln136">        panic(&quot;Failed to allocate memory for PCB Table&quot;);</a>
<a name="ln137">    }</a>
<a name="ln138"> </a>
<a name="ln139">    PCBTable-&gt;processesCount = 0;</a>
<a name="ln140">    PCBTable-&gt;current_pid = -1;</a>
<a name="ln141">    PCBTable-&gt;foreground_pid = -1;</a>
<a name="ln142"> </a>
<a name="ln143">    for (int i = 0; i &lt; MAX_PROCESSES; i++) {</a>
<a name="ln144">		PCBTable-&gt;processes[i] = NULL;</a>
<a name="ln145">	}</a>
<a name="ln146"> </a>
<a name="ln147">    return 0;</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">int startInitProcess(void * shellEntryPoint) {</a>
<a name="ln151">    if (shellEntryPoint == NULL) {</a>
<a name="ln152">        return -1;</a>
<a name="ln153">    }</a>
<a name="ln154"> </a>
<a name="ln155">    init_shell_entry = shellEntryPoint;</a>
<a name="ln156"> </a>
<a name="ln157">    char * initArgv[] = { &quot;init&quot;, NULL };</a>
<a name="ln158">    Process * initProcess = createProcess((void *)initProcessMain, 1, initArgv, MID_PRIORITY, -1, 1);</a>
<a name="ln159">    if (initProcess == NULL) {</a>
<a name="ln160">        return -1;</a>
<a name="ln161">    }</a>
<a name="ln162"> </a>
<a name="ln163">    return initProcess-&gt;pid;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166"> </a>
<a name="ln167">int getNextPid(void) {</a>
<a name="ln168">    if(PCBTable-&gt;current_pid &lt; 0){  // First PID allocation, Idle process</a>
<a name="ln169">        return 0;</a>
<a name="ln170">    }</a>
<a name="ln171">    </a>
<a name="ln172">    int start = PCBTable-&gt;current_pid + 1;</a>
<a name="ln173">    for (int i = 0; i &lt; MAX_PROCESSES; i++) {</a>
<a name="ln174">        int pid = (start + i) % MAX_PROCESSES;</a>
<a name="ln175">        if (PCBTable-&gt;processes[pid] == NULL || PCBTable-&gt;processes[pid]-&gt;stack_base == 0 || PCBTable-&gt;processes[pid]-&gt;state == PROCESS_STATE_TERMINATED) {</a>
<a name="ln176">            return pid;</a>
<a name="ln177">        }</a>
<a name="ln178">    }</a>
<a name="ln179">    return -1;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">int changePriority(int pid, ProcessPriority newPriority) {</a>
<a name="ln183">    if (pid &lt; 0 || pid &gt;= MAX_PROCESSES || newPriority &lt; MIN_PRIORITY || newPriority &gt; MAX_PRIORITY) {</a>
<a name="ln184">        return -1;</a>
<a name="ln185">    }</a>
<a name="ln186"> </a>
<a name="ln187">    Process * process = PCBTable-&gt;processes[pid];</a>
<a name="ln188">    if (process == NULL) {</a>
<a name="ln189">        return -1;</a>
<a name="ln190">    }</a>
<a name="ln191"> </a>
<a name="ln192">    ProcessPriority oldPriority = process-&gt;priority;</a>
<a name="ln193">    if (oldPriority == newPriority) {</a>
<a name="ln194">        return 0;</a>
<a name="ln195">    }</a>
<a name="ln196"> </a>
<a name="ln197">    process-&gt;priority = newPriority;</a>
<a name="ln198"> </a>
<a name="ln199">    if (process-&gt;state == PROCESS_STATE_READY) {</a>
<a name="ln200">        if (schedulerRequeueReadyProcess(process) != 0) {</a>
<a name="ln201">            process-&gt;priority = oldPriority;</a>
<a name="ln202">            return -1;</a>
<a name="ln203">        }</a>
<a name="ln204">    }</a>
<a name="ln205"> </a>
<a name="ln206">    return 0;</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">Process * createProcess(void * function, int argc, char ** argv, ProcessPriority priority, int parentID, uint8_t is_background){</a>
<a name="ln210">    if(function == NULL || argc &lt; 0 || priority &lt; 0 || (argc &gt; 0 &amp;&amp; argv == NULL)){</a>
<a name="ln211">        return NULL;</a>
<a name="ln212">    }</a>
<a name="ln213"> </a>
<a name="ln214">    int pid = getNextPid();</a>
<a name="ln215">    if (pid &lt; 0 || pid &gt;= MAX_PROCESSES) {</a>
<a name="ln216">        return NULL;</a>
<a name="ln217">    }</a>
<a name="ln218"> </a>
<a name="ln219">    // reserve stack</a>
<a name="ln220">    uint8_t * stack_base = myMalloc(PROCESS_STACK_SIZE);</a>
<a name="ln221">    if (stack_base == NULL) {</a>
<a name="ln222">        return NULL;</a>
<a name="ln223">    }</a>
<a name="ln224"> </a>
<a name="ln225">    Process * process = myMalloc(sizeof(Process));</a>
<a name="ln226">    if (process == NULL) {</a>
<a name="ln227">        myFree(stack_base);</a>
<a name="ln228">        return NULL;</a>
<a name="ln229">    }</a>
<a name="ln230"> </a>
<a name="ln231">    uint8_t * stack_top = stack_base + PROCESS_STACK_SIZE - sizeof(uint64_t); // Stack grows downwards</a>
<a name="ln232"> </a>
<a name="ln233">    process-&gt;pid = pid;</a>
<a name="ln234">    process-&gt;ppid = parentID;</a>
<a name="ln235">    process-&gt;priority = priority;</a>
<a name="ln236">    process-&gt;state = PROCESS_STATE_READY;</a>
<a name="ln237">    process-&gt;argc = argc;</a>
<a name="ln238">    process-&gt;stack_base = stack_base;</a>
<a name="ln239">    process-&gt;rip = function;</a>
<a name="ln240">    process-&gt;argv = NULL;</a>
<a name="ln241">    process-&gt;is_background = is_background;</a>
<a name="ln242">    process-&gt;is_foreground = 0;</a>
<a name="ln243">    process-&gt;waiting_for_child = -1;</a>
<a name="ln244">    process-&gt;children = createQueue(cmpInt, sizeof(int));</a>
<a name="ln245">    if(process-&gt;children == NULL){</a>
<a name="ln246">        myFree(process);</a>
<a name="ln247">        myFree(stack_base);</a>
<a name="ln248">        return NULL;</a>
<a name="ln249">    }</a>
<a name="ln250">    Process * parent = NULL;</a>
<a name="ln251">    if (parentID &gt;= 0) {</a>
<a name="ln252">        parent = getProcess(parentID);</a>
<a name="ln253">    }</a>
<a name="ln254">    if (initProcessEndpoints(process, parent) != 0) {</a>
<a name="ln255">        queueFree(process-&gt;children);</a>
<a name="ln256">        myFree(process);</a>
<a name="ln257">        myFree(stack_base);</a>
<a name="ln258">        return NULL;</a>
<a name="ln259">    }</a>
<a name="ln260">    initProcessSem(process);</a>
<a name="ln261"> </a>
<a name="ln262">    process-&gt;argv = (char **) myMalloc(sizeof(char *) * (process-&gt;argc + 1));</a>
<a name="ln263">    if (process-&gt;argv == NULL) {</a>
<a name="ln264">        myFree(process);</a>
<a name="ln265">        myFree(stack_base);</a>
<a name="ln266">        semDestroy(process-&gt;wait_sem);</a>
<a name="ln267">        queueFree(process-&gt;children);</a>
<a name="ln268">        cleanupProcessEndpoints(process);</a>
<a name="ln269">        return NULL;</a>
<a name="ln270">    }</a>
<a name="ln271"> </a>
<a name="ln272">    for (int i = 0; i &lt; argc; i++) {</a>
<a name="ln273">        int len = strlen(argv[i]);</a>
<a name="ln274">        process-&gt;argv[i] = (char *) myMalloc(sizeof(char) * (len + 1));</a>
<a name="ln275">        if (process-&gt;argv[i] == NULL) {</a>
<a name="ln276">            for (int j = 0; j &lt; i; j++) {</a>
<a name="ln277">                myFree(process-&gt;argv[j]);</a>
<a name="ln278">            }</a>
<a name="ln279">            myFree(process-&gt;argv);</a>
<a name="ln280">            myFree(process);</a>
<a name="ln281">            myFree(stack_base);</a>
<a name="ln282">            semDestroy(process-&gt;wait_sem);</a>
<a name="ln283">            queueFree(process-&gt;children);</a>
<a name="ln284">            return NULL;</a>
<a name="ln285">        }</a>
<a name="ln286">        strcpy(process-&gt;argv[i], argv[i]);</a>
<a name="ln287">        process-&gt;argv[i][len] = '\0';</a>
<a name="ln288">    }</a>
<a name="ln289">    process-&gt;argv[argc] = NULL;</a>
<a name="ln290"> </a>
<a name="ln291">    process-&gt;name = (process-&gt;argc &gt; 0) ? process-&gt;argv[0] : NULL;</a>
<a name="ln292"> </a>
<a name="ln293">    uint8_t * initial_rsp = stackInit(stack_top, function, process-&gt;argc, process-&gt;argv);</a>
<a name="ln294">    if (initial_rsp == NULL) {</a>
<a name="ln295">        if (process-&gt;argv != NULL) {</a>
<a name="ln296">            for (int i = 0; i &lt; process-&gt;argc; i++) {</a>
<a name="ln297">                myFree(process-&gt;argv[i]);</a>
<a name="ln298">            }</a>
<a name="ln299">            myFree(process-&gt;argv);</a>
<a name="ln300">        }</a>
<a name="ln301">        myFree(process);</a>
<a name="ln302">        myFree(stack_base);</a>
<a name="ln303">        semDestroy(process-&gt;wait_sem);</a>
<a name="ln304">        queueFree(process-&gt;children);</a>
<a name="ln305">        cleanupProcessEndpoints(process);</a>
<a name="ln306">        return NULL;</a>
<a name="ln307">    }</a>
<a name="ln308"> </a>
<a name="ln309">    process-&gt;rsp = initial_rsp;</a>
<a name="ln310"> </a>
<a name="ln311">    // Add process to the PCB</a>
<a name="ln312">    PCBTable-&gt;processes[pid] = process;</a>
<a name="ln313">    PCBTable-&gt;processesCount++;</a>
<a name="ln314">    PCBTable-&gt;current_pid = pid;</a>
<a name="ln315"> </a>
<a name="ln316">    int added = addProcessToScheduler(process);</a>
<a name="ln317">    if (added != 0) {</a>
<a name="ln318">        freeProcess(process);</a>
<a name="ln319">        return NULL;</a>
<a name="ln320">    }</a>
<a name="ln321"> </a>
<a name="ln322">    if (parent != NULL &amp;&amp; parent-&gt;children != NULL) {</a>
<a name="ln323">        enqueue(parent-&gt;children, &amp;process-&gt;pid);</a>
<a name="ln324">    }</a>
<a name="ln325"> </a>
<a name="ln326">    uint8_t effective_background = is_background;</a>
<a name="ln327">    if (parent != NULL &amp;&amp; parent-&gt;pid &gt; SHELL_PROCESS_PID) {</a>
<a name="ln328">        effective_background = parent-&gt;is_background;</a>
<a name="ln329">    }</a>
<a name="ln330"> </a>
<a name="ln331">    process-&gt;is_background = effective_background;</a>
<a name="ln332"> </a>
<a name="ln333">    uint8_t should_take_foreground = !effective_background &amp;&amp;</a>
<a name="ln334">                                     (parent == NULL || parent-&gt;pid &lt;= SHELL_PROCESS_PID);</a>
<a name="ln335"> </a>
<a name="ln336">    if (should_take_foreground) {</a>
<a name="ln337">        setForegroundProcess(process);</a>
<a name="ln338">    }</a>
<a name="ln339">    </a>
<a name="ln340">    return process;</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">static int initProcessMain(void) {</a>
<a name="ln344">    while (1) {</a>
<a name="ln345">        if (init_shell_entry == NULL) {</a>
<a name="ln346">            panic(&quot;Init process without shell entry&quot;);</a>
<a name="ln347">        }</a>
<a name="ln348"> </a>
<a name="ln349">        char * shellArgv[] = { &quot;shell&quot;, NULL };</a>
<a name="ln350">        Process * shell = createProcess(init_shell_entry, 1, shellArgv, MID_PRIORITY, INIT_PROCESS_PID, 0);</a>
<a name="ln351">        if (shell == NULL) {</a>
<a name="ln352">            panic(&quot;Failed to launch shell process&quot;);</a>
<a name="ln353">        }</a>
<a name="ln354"> </a>
<a name="ln355">        waitPid(shell-&gt;pid);</a>
<a name="ln356">    }</a>
<a name="ln357"> </a>
<a name="ln358">    return 0;</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">void removeProcess(Process * p){</a>
<a name="ln362">    if (p == NULL) {</a>
<a name="ln363">        return;</a>
<a name="ln364">    }</a>
<a name="ln365">    releaseForegroundProcess(p);</a>
<a name="ln366">    p-&gt;state = PROCESS_STATE_TERMINATED;</a>
<a name="ln367"> </a>
<a name="ln368">    semDestroy(p-&gt;wait_sem);</a>
<a name="ln369"> </a>
<a name="ln370">    if (PCBTable != NULL &amp;&amp; p-&gt;pid &gt;= 0 &amp;&amp; p-&gt;pid &lt; MAX_PROCESSES &amp;&amp; PCBTable-&gt;processes[p-&gt;pid] == p) {</a>
<a name="ln371">        PCBTable-&gt;processes[p-&gt;pid] = NULL;</a>
<a name="ln372">        if (PCBTable-&gt;processesCount &gt; 0) {</a>
<a name="ln373">            PCBTable-&gt;processesCount--;</a>
<a name="ln374">        }</a>
<a name="ln375">    }</a>
<a name="ln376"> </a>
<a name="ln377">    // The children of the terminated process are adopted by the process' parent.</a>
<a name="ln378">    Process * parent = getProcess(p-&gt;ppid);</a>
<a name="ln379">    if (parent != NULL &amp;&amp; parent-&gt;children != NULL) {</a>
<a name="ln380">        queueRemove(parent-&gt;children, &amp;p-&gt;pid);</a>
<a name="ln381">    }</a>
<a name="ln382">    if (parent == NULL || parent-&gt;state == PROCESS_STATE_TERMINATED) {</a>
<a name="ln383">        parent = getProcess(INIT_PROCESS_PID);</a>
<a name="ln384">    }</a>
<a name="ln385"> </a>
<a name="ln386">    if (parent == NULL || parent-&gt;state == PROCESS_STATE_TERMINATED) {</a>
<a name="ln387">        parent = getProcess(SHELL_PROCESS_PID);</a>
<a name="ln388">    }</a>
<a name="ln389"> </a>
<a name="ln390">    if (parent == NULL || parent-&gt;state == PROCESS_STATE_TERMINATED) {</a>
<a name="ln391">        parent = getProcess(IDLE_PROCESS_PID);</a>
<a name="ln392">    }</a>
<a name="ln393"> </a>
<a name="ln394">    while(!queueIsEmpty(p-&gt;children)) {</a>
<a name="ln395">        int child_pid;</a>
<a name="ln396">        dequeue(p-&gt;children, &amp;child_pid);</a>
<a name="ln397">        Process *child = getProcess(child_pid);</a>
<a name="ln398">        if (child != NULL &amp;&amp; parent != NULL) {</a>
<a name="ln399">            child-&gt;ppid = parent-&gt;pid;</a>
<a name="ln400">            if (parent-&gt;children != NULL) {</a>
<a name="ln401">                enqueue(parent-&gt;children, &amp;child-&gt;pid);</a>
<a name="ln402">            }</a>
<a name="ln403">        }</a>
<a name="ln404">    }</a>
<a name="ln405">	</a>
<a name="ln406">    freeProcess(p);</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409">void freeProcess(Process * p){</a>
<a name="ln410">    if (p-&gt;stack_base != NULL) {</a>
<a name="ln411">        myFree(p-&gt;stack_base);</a>
<a name="ln412">        p-&gt;stack_base = NULL;</a>
<a name="ln413">    }</a>
<a name="ln414"> </a>
<a name="ln415">    if (p-&gt;argv != NULL) {</a>
<a name="ln416">        for (int i = 0; i &lt; p-&gt;argc; i++) {</a>
<a name="ln417">            myFree(p-&gt;argv[i]);</a>
<a name="ln418">        }</a>
<a name="ln419">        myFree(p-&gt;argv);</a>
<a name="ln420">        p-&gt;argv = NULL;</a>
<a name="ln421">    }</a>
<a name="ln422">    cleanupProcessEndpoints(p);</a>
<a name="ln423">    queueFree(p-&gt;children);</a>
<a name="ln424">    myFree(p);</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427"> </a>
<a name="ln428">int getProcessState(Process *process){</a>
<a name="ln429">    if (process == NULL) {</a>
<a name="ln430">        return -1;</a>
<a name="ln431">    }</a>
<a name="ln432">    return process-&gt;state;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">int setProcessState(Process *process, int state){</a>
<a name="ln436">    if (process == NULL) {</a>
<a name="ln437">        return -1;</a>
<a name="ln438">    }</a>
<a name="ln439">    process-&gt;state = state;</a>
<a name="ln440">    return 0;</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">static int checkValidPid(int pid) {</a>
<a name="ln444">    return (pid &gt;= 0 &amp;&amp; pid &lt; MAX_PROCESSES);</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447">int block(int pid) {</a>
<a name="ln448">    if (!checkValidPid(pid)) {</a>
<a name="ln449">        return -1;</a>
<a name="ln450">    }</a>
<a name="ln451">    Process * p = getProcess(pid);</a>
<a name="ln452">    if (p == NULL) {</a>
<a name="ln453">        return -1;</a>
<a name="ln454">    }</a>
<a name="ln455"> </a>
<a name="ln456">    if (p-&gt;state == PROCESS_STATE_READY) {</a>
<a name="ln457">        if (removeProcessFromScheduler(p) == -1) {</a>
<a name="ln458">            return -1;</a>
<a name="ln459">        }</a>
<a name="ln460">        p-&gt;state = PROCESS_STATE_BLOCKED;</a>
<a name="ln461">        return 0;</a>
<a name="ln462">    }</a>
<a name="ln463"> </a>
<a name="ln464">    if (p-&gt;state == PROCESS_STATE_RUNNING) {</a>
<a name="ln465">        p-&gt;state = PROCESS_STATE_BLOCKED;</a>
<a name="ln466">        yield();</a>
<a name="ln467">        return 0;</a>
<a name="ln468">    }</a>
<a name="ln469"> </a>
<a name="ln470">    return -1;</a>
<a name="ln471"> </a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">int kill(int pid) {</a>
<a name="ln475">    if (!checkValidPid(pid)) {</a>
<a name="ln476">        return -1;</a>
<a name="ln477">    }</a>
<a name="ln478"> </a>
<a name="ln479">    if (pid == IDLE_PROCESS_PID || pid == INIT_PROCESS_PID || pid == SHELL_PROCESS_PID) {  // designed to prevent from killing system processes, shell included</a>
<a name="ln480">        return -1;</a>
<a name="ln481">    }</a>
<a name="ln482"> </a>
<a name="ln483">    Process * process = getProcess(pid);</a>
<a name="ln484">    if (process == NULL) {</a>
<a name="ln485">        return -1;</a>
<a name="ln486">    }</a>
<a name="ln487">    </a>
<a name="ln488">    releaseForegroundProcess(process);</a>
<a name="ln489">    </a>
<a name="ln490">    ProcessState previousState = process-&gt;state;</a>
<a name="ln491">    if (previousState == PROCESS_STATE_TERMINATED) {</a>
<a name="ln492">        return 0;</a>
<a name="ln493">    }</a>
<a name="ln494"> </a>
<a name="ln495">    if (previousState == PROCESS_STATE_READY) {</a>
<a name="ln496">        if (removeProcessFromScheduler(process) == -1) {</a>
<a name="ln497">            return -1;</a>
<a name="ln498">        }</a>
<a name="ln499">    }</a>
<a name="ln500"> </a>
<a name="ln501">    // Mark process as terminated</a>
<a name="ln502">    process-&gt;state = PROCESS_STATE_TERMINATED;</a>
<a name="ln503">    if (previousState == PROCESS_STATE_RUNNING) {</a>
<a name="ln504">        enqueueTerminatedProcess(process);</a>
<a name="ln505">        // interrupt the current process to switch context</a>
<a name="ln506">        yield();</a>
<a name="ln507">        return 0;</a>
<a name="ln508">    }</a>
<a name="ln509"> </a>
<a name="ln510">    removeProcess(process);</a>
<a name="ln511">    return 0;</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">int unblock(int pid) {</a>
<a name="ln515">    Process * process = getProcess(pid);</a>
<a name="ln516">    if (process == NULL) {</a>
<a name="ln517">        return -1;</a>
<a name="ln518">    }</a>
<a name="ln519"> </a>
<a name="ln520">    if(process-&gt;state != PROCESS_STATE_BLOCKED) {</a>
<a name="ln521">        return -1;</a>
<a name="ln522">    }</a>
<a name="ln523">    process-&gt;state = PROCESS_STATE_READY;</a>
<a name="ln524">    addProcessToScheduler(process);</a>
<a name="ln525">    return 0;</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">int nice(int pid, int newPriority) {</a>
<a name="ln529">    if (!checkValidPid(pid)) {</a>
<a name="ln530">        return -1;</a>
<a name="ln531">    }</a>
<a name="ln532">    </a>
<a name="ln533">    if (newPriority &lt; MIN_PRIORITY || newPriority &gt; MAX_PRIORITY) {</a>
<a name="ln534">        return -1;</a>
<a name="ln535">    }</a>
<a name="ln536"> </a>
<a name="ln537">    Process * process = getProcess(pid);</a>
<a name="ln538">    if (process == NULL) {</a>
<a name="ln539">        return -1;</a>
<a name="ln540">    }</a>
<a name="ln541"> </a>
<a name="ln542">    int oldPriority = process-&gt;priority;</a>
<a name="ln543">    if (oldPriority == newPriority) {</a>
<a name="ln544">        return 0;</a>
<a name="ln545">    }</a>
<a name="ln546"> </a>
<a name="ln547">    process-&gt;priority = newPriority;</a>
<a name="ln548"> </a>
<a name="ln549">    if (process-&gt;state == PROCESS_STATE_READY) {</a>
<a name="ln550">        if (schedulerRequeueReadyProcess(process) != 0) {</a>
<a name="ln551">            process-&gt;priority = oldPriority;</a>
<a name="ln552">            return -1;</a>
<a name="ln553">        }</a>
<a name="ln554">    }</a>
<a name="ln555"> </a>
<a name="ln556">    return 0;</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">int waitPid(int pid) {</a>
<a name="ln560">    Process * p = getProcess(pid);</a>
<a name="ln561">    if (p == NULL) {</a>
<a name="ln562">        return -1; // Child process doesn't exist</a>
<a name="ln563">    }</a>
<a name="ln564"> </a>
<a name="ln565">    Process * current = getCurrentProcess();</a>
<a name="ln566">    if (current == NULL) {</a>
<a name="ln567">        return -1;</a>
<a name="ln568">    }</a>
<a name="ln569"> </a>
<a name="ln570">    // Child is already terminated</a>
<a name="ln571">    if (p-&gt;state == PROCESS_STATE_TERMINATED) {</a>
<a name="ln572">        if (current-&gt;children != NULL) {</a>
<a name="ln573">            queueRemove(current-&gt;children, &amp;pid);</a>
<a name="ln574">        }</a>
<a name="ln575">        return 0;</a>
<a name="ln576">    }</a>
<a name="ln577">    if(p-&gt;wait_sem == NULL) {</a>
<a name="ln578">        return -1;</a>
<a name="ln579">    }</a>
<a name="ln580">    int waitResult = wait(p-&gt;wait_sem);</a>
<a name="ln581">    if (current-&gt;children != NULL) {</a>
<a name="ln582">        queueRemove(current-&gt;children, &amp;pid);</a>
<a name="ln583">    }</a>
<a name="ln584">    return waitResult;</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587">int waitChildren(void) {</a>
<a name="ln588">    Process * current = getCurrentProcess();</a>
<a name="ln589">    if (current == NULL) {</a>
<a name="ln590">        return -1;</a>
<a name="ln591">    }</a>
<a name="ln592"> </a>
<a name="ln593">    if (current-&gt;children == NULL || queueIsEmpty(current-&gt;children)) {</a>
<a name="ln594">        return 0;</a>
<a name="ln595">    }</a>
<a name="ln596"> </a>
<a name="ln597">    int childCount = queueSize(current-&gt;children);</a>
<a name="ln598">    if (childCount &lt;= 0) {</a>
<a name="ln599">        return 0;</a>
<a name="ln600">    }</a>
<a name="ln601"> </a>
<a name="ln602">    if (childCount &gt; MAX_PROCESSES) {</a>
<a name="ln603">        childCount = MAX_PROCESSES;</a>
<a name="ln604">    }</a>
<a name="ln605"> </a>
<a name="ln606">    int childPids[MAX_PROCESSES];</a>
<a name="ln607"> </a>
<a name="ln608">    if (queueBeginCyclicIter(current-&gt;children) == NULL) {</a>
<a name="ln609">        return 0;</a>
<a name="ln610">    }</a>
<a name="ln611"> </a>
<a name="ln612">    for (int i = 0; i &lt; childCount; i++) {</a>
<a name="ln613">        queueNextCyclicIter(current-&gt;children, &amp;childPids[i]);</a>
<a name="ln614">    }</a>
<a name="ln615"> </a>
<a name="ln616">    int result = 0;</a>
<a name="ln617"> </a>
<a name="ln618">    for (int i = 0; i &lt; childCount; i++) {</a>
<a name="ln619">        int pid = childPids[i];</a>
<a name="ln620">        Process * child = getProcess(pid);</a>
<a name="ln621">        if (child == NULL) {</a>
<a name="ln622">            queueRemove(current-&gt;children, &amp;pid);</a>
<a name="ln623">            continue;</a>
<a name="ln624">        }</a>
<a name="ln625"> </a>
<a name="ln626">        if (child-&gt;state == PROCESS_STATE_TERMINATED) {</a>
<a name="ln627">            queueRemove(current-&gt;children, &amp;pid);</a>
<a name="ln628">            continue;</a>
<a name="ln629">        }</a>
<a name="ln630"> </a>
<a name="ln631">        if (child-&gt;wait_sem == NULL) {</a>
<a name="ln632">            queueRemove(current-&gt;children, &amp;pid);</a>
<a name="ln633">            result = -1;</a>
<a name="ln634">            continue;</a>
<a name="ln635">        }</a>
<a name="ln636"> </a>
<a name="ln637">        if (wait(child-&gt;wait_sem) != 0) {</a>
<a name="ln638">            result = -1;</a>
<a name="ln639">        }</a>
<a name="ln640"> </a>
<a name="ln641">        queueRemove(current-&gt;children, &amp;pid);</a>
<a name="ln642">    }</a>
<a name="ln643"> </a>
<a name="ln644">    return result;</a>
<a name="ln645">}</a>
<a name="ln646"> </a>
<a name="ln647">Process * getProcess(int pid) {</a>
<a name="ln648">	if (PCBTable == NULL || !checkValidPid(pid)) {</a>
<a name="ln649">		return NULL;</a>
<a name="ln650">	}</a>
<a name="ln651">	return PCBTable-&gt;processes[pid];</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654"> </a>
<a name="ln655">int getProcessInfo(int pid, ProcessInformation * info){</a>
<a name="ln656">    if(info == NULL || !checkValidPid(pid)){</a>
<a name="ln657">        return -1;</a>
<a name="ln658">    }</a>
<a name="ln659"> </a>
<a name="ln660">    _cli();</a>
<a name="ln661">    Process * process = getProcess(pid);</a>
<a name="ln662">    if(process == NULL){</a>
<a name="ln663">        _sti();</a>
<a name="ln664">        return -1;</a>
<a name="ln665">    }</a>
<a name="ln666"> </a>
<a name="ln667">    info-&gt;pid = process-&gt;pid;</a>
<a name="ln668"> </a>
<a name="ln669">    if (process-&gt;name != NULL) {</a>
<a name="ln670">        strncpy(info-&gt;name, process-&gt;name, PROCESS_NAME_MAX_LENGTH - 1);</a>
<a name="ln671">        info-&gt;name[PROCESS_NAME_MAX_LENGTH - 1] = '\0';</a>
<a name="ln672">    } else {</a>
<a name="ln673">        info-&gt;name[0] = '\0';</a>
<a name="ln674">    }</a>
<a name="ln675"> </a>
<a name="ln676">    info-&gt;priority = process-&gt;priority;</a>
<a name="ln677">    info-&gt;state = process-&gt;state;</a>
<a name="ln678">    info-&gt;rsp = process-&gt;rsp;</a>
<a name="ln679">    info-&gt;stack_base = process-&gt;stack_base;</a>
<a name="ln680">    info-&gt;is_foreground = process-&gt;is_foreground;</a>
<a name="ln681">    _sti();</a>
<a name="ln682">    return 0;</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">Process * getForegroundProcess(void) {</a>
<a name="ln686">    if (PCBTable == NULL) {</a>
<a name="ln687">        return NULL;</a>
<a name="ln688">    }</a>
<a name="ln689"> </a>
<a name="ln690">    _cli();</a>
<a name="ln691">    int pid = PCBTable-&gt;foreground_pid;</a>
<a name="ln692">    Process *process = NULL;</a>
<a name="ln693">    if (pid &gt;= 0 &amp;&amp; pid &lt; MAX_PROCESSES) {</a>
<a name="ln694">        process = PCBTable-&gt;processes[pid];</a>
<a name="ln695">    }</a>
<a name="ln696">    _sti();</a>
<a name="ln697">    return process;</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">void setForegroundProcess(Process * process) {</a>
<a name="ln701">    if (PCBTable == NULL) {</a>
<a name="ln702">        return;</a>
<a name="ln703">    }</a>
<a name="ln704"> </a>
<a name="ln705">    _cli();</a>
<a name="ln706">    int currentPid = PCBTable-&gt;foreground_pid;</a>
<a name="ln707">    if (currentPid &gt;= 0 &amp;&amp; currentPid &lt; MAX_PROCESSES) {</a>
<a name="ln708">        Process *current = PCBTable-&gt;processes[currentPid];</a>
<a name="ln709">        if (current != NULL) {</a>
<a name="ln710">            current-&gt;is_foreground = 0;</a>
<a name="ln711">        }</a>
<a name="ln712">    }</a>
<a name="ln713"> </a>
<a name="ln714">    if (process != NULL) {</a>
<a name="ln715">        PCBTable-&gt;foreground_pid = process-&gt;pid;</a>
<a name="ln716">        process-&gt;is_foreground = 1;</a>
<a name="ln717">    } else {</a>
<a name="ln718">        PCBTable-&gt;foreground_pid = -1;</a>
<a name="ln719">    }</a>
<a name="ln720">    _sti();</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">void releaseForegroundProcess(Process * process) {</a>
<a name="ln724">    if (process == NULL) {</a>
<a name="ln725">        return;</a>
<a name="ln726">    }</a>
<a name="ln727"> </a>
<a name="ln728">    Process *current = getForegroundProcess();</a>
<a name="ln729">    if (current == NULL || current-&gt;pid != process-&gt;pid) {</a>
<a name="ln730">        return; </a>
<a name="ln731">    }</a>
<a name="ln732"> </a>
<a name="ln733">    Process *candidate = getProcess(process-&gt;ppid);</a>
<a name="ln734">    if (candidate == NULL || candidate-&gt;state == PROCESS_STATE_TERMINATED) {</a>
<a name="ln735">        candidate = getProcess(INIT_PROCESS_PID);</a>
<a name="ln736">    }</a>
<a name="ln737"> </a>
<a name="ln738">    if (candidate == NULL || candidate-&gt;state == PROCESS_STATE_TERMINATED) {</a>
<a name="ln739">        candidate = getProcess(SHELL_PROCESS_PID);</a>
<a name="ln740">    }</a>
<a name="ln741"> </a>
<a name="ln742">    if (candidate == NULL || candidate-&gt;state == PROCESS_STATE_TERMINATED) {</a>
<a name="ln743">        candidate = getProcess(IDLE_PROCESS_PID);</a>
<a name="ln744">    }</a>
<a name="ln745"> </a>
<a name="ln746">    setForegroundProcess(candidate);</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">int killForegroundProcess(void) {</a>
<a name="ln750">    Process *foreground = getForegroundProcess();</a>
<a name="ln751">    if (foreground == NULL) {</a>
<a name="ln752">        return -1;</a>
<a name="ln753">    }</a>
<a name="ln754"> </a>
<a name="ln755">    if (foreground-&gt;pid &lt;= SHELL_PROCESS_PID) {</a>
<a name="ln756">        // Never kill idle/init/shell via Ctrl+C</a>
<a name="ln757">        return -1;</a>
<a name="ln758">    }</a>
<a name="ln759"> </a>
<a name="ln760">    return kill(foreground-&gt;pid);</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763">int ps(ProcessInformation * processInfoTable){</a>
<a name="ln764">    if(processInfoTable == NULL){</a>
<a name="ln765">        return -1;</a>
<a name="ln766">    }</a>
<a name="ln767"> </a>
<a name="ln768">    int count = 0;</a>
<a name="ln769">    for(int pid = 0; pid &lt; MAX_PROCESSES; pid++){</a>
<a name="ln770">        if(getProcessInfo(pid, &amp;processInfoTable[count]) == 0){</a>
<a name="ln771">            count++;</a>
<a name="ln772">        }</a>
<a name="ln773">    }</a>
<a name="ln774">    return count;</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">int getCurrentPid() {</a>
<a name="ln778">    Process * current = getCurrentProcess();</a>
<a name="ln779">    if (current == NULL) {</a>
<a name="ln780">        return -1;</a>
<a name="ln781">    }</a>
<a name="ln782">    return current-&gt;pid;</a>
<a name="ln783">}</a>
</code></pre>
<div class="balloon" rel="215"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always false: pid &gt;= 64.</p></div>
<div class="balloon" rel="295"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'process-&gt;argv != NULL' is always true.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>