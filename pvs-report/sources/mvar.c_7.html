<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mvar.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3">#include &quot;commands.h&quot;</a>
<a name="ln4"> </a>
<a name="ln5">#ifdef ANSI_4_BIT_COLOR_SUPPORT</a>
<a name="ln6">#define COLOR_RESET   &quot;\e[0m&quot;</a>
<a name="ln7">#define COLOR_WHITE   &quot;\e[1;37m&quot;</a>
<a name="ln8">#define COLOR_RED     &quot;\e[0;31m&quot;</a>
<a name="ln9">#define COLOR_GREEN   &quot;\e[0;32m&quot;</a>
<a name="ln10">#define COLOR_CYAN    &quot;\e[0;36m&quot;</a>
<a name="ln11">#define COLOR_YELLOW  &quot;\e[0;33m&quot;</a>
<a name="ln12">#define COLOR_BLUE    &quot;\e[0;34m&quot;</a>
<a name="ln13">#define COLOR_MAGENTA &quot;\e[0;35m&quot;</a>
<a name="ln14">#else</a>
<a name="ln15">#define COLOR_RESET   &quot;&quot;</a>
<a name="ln16">#define COLOR_WHITE   &quot;&quot;</a>
<a name="ln17">#define COLOR_RED     &quot;&quot;</a>
<a name="ln18">#define COLOR_GREEN   &quot;&quot;</a>
<a name="ln19">#define COLOR_CYAN    &quot;&quot;</a>
<a name="ln20">#define COLOR_YELLOW  &quot;&quot;</a>
<a name="ln21">#define COLOR_BLUE    &quot;&quot;</a>
<a name="ln22">#define COLOR_MAGENTA &quot;&quot;</a>
<a name="ln23">#endif</a>
<a name="ln24"> </a>
<a name="ln25">static const char *const reader_colors[] = {</a>
<a name="ln26">	COLOR_RED,</a>
<a name="ln27">	COLOR_GREEN,</a>
<a name="ln28">	COLOR_CYAN,</a>
<a name="ln29">	COLOR_YELLOW,</a>
<a name="ln30">	COLOR_BLUE,</a>
<a name="ln31">	COLOR_MAGENTA,</a>
<a name="ln32">	COLOR_WHITE,</a>
<a name="ln33">};</a>
<a name="ln34"> </a>
<a name="ln35">#define READER_COLOR_COUNT (sizeof(reader_colors) / sizeof(reader_colors[0]))</a>
<a name="ln36">#define MAX_TRACKED_MVAR_CHILDREN 64</a>
<a name="ln37"> </a>
<a name="ln38">#define MVAR_EMPTY_SEM_NAME &quot;mvar-empty&quot;</a>
<a name="ln39">#define MVAR_FULL_SEM_NAME &quot;mvar-full&quot;</a>
<a name="ln40"> </a>
<a name="ln41">typedef struct {</a>
<a name="ln42">	void *sem_empty;</a>
<a name="ln43">	void *sem_full;</a>
<a name="ln44">	volatile char slot;</a>
<a name="ln45">	uint8_t initialized;</a>
<a name="ln46">} KernelMVar;</a>
<a name="ln47"> </a>
<a name="ln48">static KernelMVar kernel_mvar = {0};</a>
<a name="ln49">static int nR;</a>
<a name="ln50">static int nW;</a>
<a name="ln51">static int mvar_child_pids[MAX_TRACKED_MVAR_CHILDREN];</a>
<a name="ln52">static int mvar_child_count = 0;</a>
<a name="ln53">static uint8_t mvar_tracking_initialized = 0;</a>
<a name="ln54"> </a>
<a name="ln55">static void busy_wait(uint64_t iter);</a>
<a name="ln56">static uint32_t rng_next(uint32_t seed);</a>
<a name="ln57">static const char *color_of_reader(const char *idstr);</a>
<a name="ln58">static int parse_loop_limit(int argc, char **argv);</a>
<a name="ln59">static void mvar_tracking_init(void);</a>
<a name="ln60">static void mvar_reset_tracking(void);</a>
<a name="ln61">static int mvar_register_child(int pid);</a>
<a name="ln62">static int mvar_pid_is_alive(int pid);</a>
<a name="ln63">static int mvar_has_active_children(void);</a>
<a name="ln64">static int mvar_kill_tracked_children(void);</a>
<a name="ln65">static void mvar_cleanup_all(void);</a>
<a name="ln66">static int kernel_mvar_open(void);</a>
<a name="ln67">static void kernel_mvar_destroy(void);</a>
<a name="ln68">static int kernel_mvar_put(char value);</a>
<a name="ln69">static int kernel_mvar_take(char *value);</a>
<a name="ln70">static int writerMain(int argc, char **argv);</a>
<a name="ln71">static int readerMain(int argc, char **argv);</a>
<a name="ln72">int _mvar_close(int argc, char **argv);</a>
<a name="ln73"> </a>
<a name="ln74">static void busy_wait(uint64_t iter) {</a>
<a name="ln75">	for (uint64_t i = 0; i &lt; iter; i++) {</a>
<a name="ln76">		yield();</a>
<a name="ln77">	}</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">static uint32_t rng_next(uint32_t seed) {</a>
<a name="ln81">	int hour = 0;</a>
<a name="ln82">	int minute = 0;</a>
<a name="ln83">	int second = 0;</a>
<a name="ln84">	getDate(&amp;hour, &amp;minute, &amp;second);</a>
<a name="ln85"> </a>
<a name="ln86">	uint32_t time_mix = (uint32_t)(hour * 3600 + minute * 60 + second);</a>
<a name="ln87">	int32_t pid = getPid();</a>
<a name="ln88">	uint32_t pid_component = (pid &lt; 0) ? 0u : (uint32_t)pid;</a>
<a name="ln89">	uint32_t mixed = seed ^ time_mix ^ pid_component;</a>
<a name="ln90">	return mixed * 1664525u + 1013904223u;</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">static const char *color_of_reader(const char *idstr) {</a>
<a name="ln94">	if (READER_COLOR_COUNT == 0) {</a>
<a name="ln95">		return COLOR_RESET;</a>
<a name="ln96">	}</a>
<a name="ln97"> </a>
<a name="ln98">	if (idstr != NULL &amp;&amp; idstr[0] == 'R' &amp;&amp; idstr[1] &gt;= '0' &amp;&amp; idstr[1] &lt;= '9') {</a>
<a name="ln99">		return reader_colors[(idstr[1] - '0') % READER_COLOR_COUNT];</a>
<a name="ln100">	}</a>
<a name="ln101"> </a>
<a name="ln102">	int32_t pid = getPid();</a>
<a name="ln103">	if (pid &lt; 0) {</a>
<a name="ln104">		pid = 0;</a>
<a name="ln105">	}</a>
<a name="ln106">	return reader_colors[(uint32_t)pid % READER_COLOR_COUNT];</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">static int parse_loop_limit(int argc, char **argv) {</a>
<a name="ln110">	if (argc &lt; 2 || argv == NULL || argv[1] == NULL) {</a>
<a name="ln111">		return -1;</a>
<a name="ln112">	}</a>
<a name="ln113">	int parsed = (int)satoi(argv[1]);</a>
<a name="ln114">	return (parsed &gt; 0) ? parsed : -1;</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">static void mvar_tracking_init(void) {</a>
<a name="ln118">	if (mvar_tracking_initialized) {</a>
<a name="ln119">		return;</a>
<a name="ln120">	}</a>
<a name="ln121">	for (int i = 0; i &lt; MAX_TRACKED_MVAR_CHILDREN; i++) {</a>
<a name="ln122">		mvar_child_pids[i] = -1;</a>
<a name="ln123">	}</a>
<a name="ln124">	mvar_child_count = 0;</a>
<a name="ln125">	mvar_tracking_initialized = 1;</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">static void mvar_reset_tracking(void) {</a>
<a name="ln129">	for (int i = 0; i &lt; MAX_TRACKED_MVAR_CHILDREN; i++) {</a>
<a name="ln130">		mvar_child_pids[i] = -1;</a>
<a name="ln131">	}</a>
<a name="ln132">	mvar_child_count = 0;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">static int mvar_register_child(int pid) {</a>
<a name="ln136">	if (pid &lt;= 0) {</a>
<a name="ln137">		return -1;</a>
<a name="ln138">	}</a>
<a name="ln139">	mvar_tracking_init();</a>
<a name="ln140">	if (mvar_child_count &gt;= MAX_TRACKED_MVAR_CHILDREN) {</a>
<a name="ln141">		return -1;</a>
<a name="ln142">	}</a>
<a name="ln143">	mvar_child_pids[mvar_child_count++] = pid;</a>
<a name="ln144">	return 0;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">static int mvar_pid_is_alive(int pid) {</a>
<a name="ln148">	if (pid &lt;= 0) {</a>
<a name="ln149">		return 0;</a>
<a name="ln150">	}</a>
<a name="ln151">	ProcessInformation info;</a>
<a name="ln152">	if (getProcessInfo(pid, &amp;info) != 0) {</a>
<a name="ln153">		return 0;</a>
<a name="ln154">	}</a>
<a name="ln155">	return info.state != PROCESS_STATE_TERMINATED;</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">static int mvar_has_active_children(void) {</a>
<a name="ln159">	mvar_tracking_init();</a>
<a name="ln160">	for (int i = 0; i &lt; mvar_child_count; i++) {</a>
<a name="ln161">		if (mvar_pid_is_alive(mvar_child_pids[i])) {</a>
<a name="ln162">			return 1;</a>
<a name="ln163">		}</a>
<a name="ln164">	}</a>
<a name="ln165">	return 0;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168">static int mvar_kill_tracked_children(void) {</a>
<a name="ln169">	mvar_tracking_init();</a>
<a name="ln170">	int killed = 0;</a>
<a name="ln171">	for (int i = 0; i &lt; mvar_child_count; i++) {</a>
<a name="ln172">		int pid = mvar_child_pids[i];</a>
<a name="ln173">		if (pid &lt;= 0) {</a>
<a name="ln174">			continue;</a>
<a name="ln175">		}</a>
<a name="ln176">		if (!mvar_pid_is_alive(pid)) {</a>
<a name="ln177">			continue;</a>
<a name="ln178">		}</a>
<a name="ln179">		if (kill(pid) == 0) {</a>
<a name="ln180">			killed++;</a>
<a name="ln181">		}</a>
<a name="ln182">	}</a>
<a name="ln183">	return killed;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">static void mvar_cleanup_all(void) {</a>
<a name="ln187">	mvar_kill_tracked_children();</a>
<a name="ln188">	kernel_mvar_destroy();</a>
<a name="ln189">	mvar_reset_tracking();</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">static int kernel_mvar_open(void) {</a>
<a name="ln193">	if (kernel_mvar.initialized) {</a>
<a name="ln194">		return 0;</a>
<a name="ln195">	}</a>
<a name="ln196"> </a>
<a name="ln197">	kernel_mvar.sem_empty = semInit(MVAR_EMPTY_SEM_NAME, 1);</a>
<a name="ln198">	kernel_mvar.sem_full = semInit(MVAR_FULL_SEM_NAME, 0);</a>
<a name="ln199"> </a>
<a name="ln200">	if (kernel_mvar.sem_empty == NULL || kernel_mvar.sem_full == NULL) {</a>
<a name="ln201">		if (kernel_mvar.sem_empty != NULL) {</a>
<a name="ln202">			semDestroy(kernel_mvar.sem_empty);</a>
<a name="ln203">			kernel_mvar.sem_empty = NULL;</a>
<a name="ln204">		}</a>
<a name="ln205">		if (kernel_mvar.sem_full != NULL) {</a>
<a name="ln206">			semDestroy(kernel_mvar.sem_full);</a>
<a name="ln207">			kernel_mvar.sem_full = NULL;</a>
<a name="ln208">		}</a>
<a name="ln209">		kernel_mvar.initialized = 0;</a>
<a name="ln210">		return -1;</a>
<a name="ln211">	}</a>
<a name="ln212"> </a>
<a name="ln213">	kernel_mvar.slot = 0;</a>
<a name="ln214">	kernel_mvar.initialized = 1;</a>
<a name="ln215">	return 0;</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">static void kernel_mvar_destroy(void) {</a>
<a name="ln219">	if (!kernel_mvar.initialized) {</a>
<a name="ln220">		return;</a>
<a name="ln221">	}</a>
<a name="ln222"> </a>
<a name="ln223">	if (kernel_mvar.sem_empty != NULL) {</a>
<a name="ln224">		semDestroy(kernel_mvar.sem_empty);</a>
<a name="ln225">		kernel_mvar.sem_empty = NULL;</a>
<a name="ln226">	}</a>
<a name="ln227">	if (kernel_mvar.sem_full != NULL) {</a>
<a name="ln228">		semDestroy(kernel_mvar.sem_full);</a>
<a name="ln229">		kernel_mvar.sem_full = NULL;</a>
<a name="ln230">	}</a>
<a name="ln231">	kernel_mvar.slot = 0;</a>
<a name="ln232">	kernel_mvar.initialized = 0;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">static int kernel_mvar_put(char value) {</a>
<a name="ln236">	if (!kernel_mvar.initialized) {</a>
<a name="ln237">		return -1;</a>
<a name="ln238">	}</a>
<a name="ln239"> </a>
<a name="ln240">	if (semWait(kernel_mvar.sem_empty) &lt; 0) {</a>
<a name="ln241">		return -1;</a>
<a name="ln242">	}</a>
<a name="ln243"> </a>
<a name="ln244">	kernel_mvar.slot = value;</a>
<a name="ln245"> </a>
<a name="ln246">	if (semPost(kernel_mvar.sem_full) &lt; 0) {</a>
<a name="ln247">		return -1;</a>
<a name="ln248">	}</a>
<a name="ln249"> </a>
<a name="ln250">	return 0;</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">static int kernel_mvar_take(char *value) {</a>
<a name="ln254">	if (!kernel_mvar.initialized || value == NULL) {</a>
<a name="ln255">		return -1;</a>
<a name="ln256">	}</a>
<a name="ln257"> </a>
<a name="ln258">	if (semWait(kernel_mvar.sem_full) &lt; 0) {</a>
<a name="ln259">		return -1;</a>
<a name="ln260">	}</a>
<a name="ln261"> </a>
<a name="ln262">	*value = kernel_mvar.slot;</a>
<a name="ln263"> </a>
<a name="ln264">	if (semPost(kernel_mvar.sem_empty) &lt; 0) {</a>
<a name="ln265">		return -1;</a>
<a name="ln266">	}</a>
<a name="ln267"> </a>
<a name="ln268">	return 0;</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">static int writerMain(int argc, char **argv) {</a>
<a name="ln272">	if (argv == NULL || argc &lt; 1 || argv[0] == NULL) {</a>
<a name="ln273">		return -1;</a>
<a name="ln274">	}</a>
<a name="ln275"> </a>
<a name="ln276">	char id = argv[0][0];</a>
<a name="ln277">	int max_loops = parse_loop_limit(argc, argv);</a>
<a name="ln278"> </a>
<a name="ln279">	uint32_t seed = (uint32_t)((getPid() &lt; 0) ? 0 : getPid());</a>
<a name="ln280"> </a>
<a name="ln281">	for (int i = 0; max_loops &lt; 0 || i &lt; max_loops; i++) {</a>
<a name="ln282">		seed = rng_next(seed);</a>
<a name="ln283">		busy_wait((seed % 50U) + 1U);</a>
<a name="ln284"> </a>
<a name="ln285">		if (kernel_mvar_put(id) &lt; 0) {</a>
<a name="ln286">			printf(&quot;mvar: writer failed to put value\n&quot;);</a>
<a name="ln287">			return -1;</a>
<a name="ln288">		}</a>
<a name="ln289">	}</a>
<a name="ln290"> </a>
<a name="ln291">	return 0;</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">static int readerMain(int argc, char **argv) {</a>
<a name="ln295">	if (argv == NULL || argc &lt; 1 || argv[0] == NULL) {</a>
<a name="ln296">		return -1;</a>
<a name="ln297">	}</a>
<a name="ln298"> </a>
<a name="ln299">	const char *idstr = argv[0];</a>
<a name="ln300">	int max_loops = parse_loop_limit(argc, argv);</a>
<a name="ln301"> </a>
<a name="ln302">	uint32_t seed = (uint32_t)((getPid() &lt; 0) ? 0 : getPid());</a>
<a name="ln303"> </a>
<a name="ln304">	for (int i = 0; max_loops &lt; 0 || i &lt; max_loops; i++) {</a>
<a name="ln305">		seed = rng_next(seed);</a>
<a name="ln306">		busy_wait((seed % 60U) + 1U);</a>
<a name="ln307"> </a>
<a name="ln308">		char value = 0;</a>
<a name="ln309">		if (kernel_mvar_take(&amp;value) &lt; 0) {</a>
<a name="ln310">			printf(&quot;mvar: reader failed to take value\n&quot;);</a>
<a name="ln311">			return -1;</a>
<a name="ln312">		}</a>
<a name="ln313"> </a>
<a name="ln314">		const char *reader_color = color_of_reader(idstr);</a>
<a name="ln315">		printf(&quot;%s%c%s&quot;, reader_color, value, COLOR_RESET);</a>
<a name="ln316">	}</a>
<a name="ln317"> </a>
<a name="ln318">	return 0;</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">int _mvar(int argc, char **argv) {</a>
<a name="ln322">	if (argc != 3) {</a>
<a name="ln323">		printf(&quot;Usage: mvar &lt;writers&gt; &lt;readers&gt;\n&quot;);</a>
<a name="ln324">		return -1;</a>
<a name="ln325">	}</a>
<a name="ln326"> </a>
<a name="ln327">	nW = satoi(argv[1]);</a>
<a name="ln328">	nR = satoi(argv[2]);</a>
<a name="ln329"> </a>
<a name="ln330">	if (nW &lt;= 0 || nR &lt;= 0) {</a>
<a name="ln331">		printf(&quot;mvar: invalid writers/readers\n&quot;);</a>
<a name="ln332">		return -1;</a>
<a name="ln333">	}</a>
<a name="ln334"> </a>
<a name="ln335">	mvar_tracking_init();</a>
<a name="ln336">	if (mvar_has_active_children()) {</a>
<a name="ln337">		printf(&quot;mvar: readers/writers already running; finish them with 'mvar-close' first\n&quot;);</a>
<a name="ln338">		return -1;</a>
<a name="ln339">	}</a>
<a name="ln340">	if (kernel_mvar.initialized) {</a>
<a name="ln341">		printf(&quot;mvar: kernel MVar already active; run 'mvar-close' to reset it\n&quot;);</a>
<a name="ln342">		return -1;</a>
<a name="ln343">	}</a>
<a name="ln344">	mvar_reset_tracking();</a>
<a name="ln345"> </a>
<a name="ln346">	if (kernel_mvar_open() &lt; 0) {</a>
<a name="ln347">		printf(&quot;mvar: error opening kernel mvar\n&quot;);</a>
<a name="ln348">		return -1;</a>
<a name="ln349">	}</a>
<a name="ln350"> </a>
<a name="ln351">	const char *reminder = &quot;Remember to run 'mvar-close' (Ctrl+K) after this to clean up the kernel MVar&quot;;</a>
<a name="ln352">	printf(&quot;%s%s%s\n&quot;, COLOR_BLUE, reminder, COLOR_RESET);</a>
<a name="ln353"> </a>
<a name="ln354">	for (int i = 0; i &lt; nW; i++) {</a>
<a name="ln355">		char letter[2];</a>
<a name="ln356">		letter[0] = 'A' + (i % 26);</a>
<a name="ln357">		letter[1] = '\0';</a>
<a name="ln358"> </a>
<a name="ln359">		char *wargs[] = {letter, NULL};</a>
<a name="ln360">		int32_t pid = createProcess((void *)writerMain, 1, (uint8_t **)wargs, 0);</a>
<a name="ln361">		if (pid &lt; 0) {</a>
<a name="ln362">			printf(&quot;mvar: failed to create writer process\n&quot;);</a>
<a name="ln363">			mvar_cleanup_all();</a>
<a name="ln364">			return -1;</a>
<a name="ln365">		}</a>
<a name="ln366">		if (mvar_register_child(pid) &lt; 0) {</a>
<a name="ln367">			printf(&quot;mvar: too many mvar processes, aborting\n&quot;);</a>
<a name="ln368">			kill(pid);</a>
<a name="ln369">			mvar_cleanup_all();</a>
<a name="ln370">			return -1;</a>
<a name="ln371">		}</a>
<a name="ln372">	}</a>
<a name="ln373"> </a>
<a name="ln374">	for (int i = 0; i &lt; nR; i++) {</a>
<a name="ln375">		char idbuf[3];</a>
<a name="ln376">		idbuf[0] = 'R';</a>
<a name="ln377">		idbuf[1] = '0' + (i % 10);</a>
<a name="ln378">		idbuf[2] = '\0';</a>
<a name="ln379"> </a>
<a name="ln380">		char *rargs[] = {idbuf, NULL};</a>
<a name="ln381">		int32_t pid = createProcess((void *)readerMain, 1, (uint8_t **)rargs, 0);</a>
<a name="ln382">		if (pid &lt; 0) {</a>
<a name="ln383">			printf(&quot;mvar: failed to create reader process\n&quot;);</a>
<a name="ln384">			mvar_cleanup_all();</a>
<a name="ln385">			return -1;</a>
<a name="ln386">		}</a>
<a name="ln387">		if (mvar_register_child(pid) &lt; 0) {</a>
<a name="ln388">			printf(&quot;mvar: too many mvar processes, aborting\n&quot;);</a>
<a name="ln389">			kill(pid);</a>
<a name="ln390">			mvar_cleanup_all();</a>
<a name="ln391">			return -1;</a>
<a name="ln392">		}</a>
<a name="ln393">	}</a>
<a name="ln394"> </a>
<a name="ln395">	return 0;</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">int _mvar_close(int argc, char **argv) {</a>
<a name="ln399">	if (argc != 1) {</a>
<a name="ln400">		printf(&quot;Usage: mvar-close\n&quot;);</a>
<a name="ln401">		return -1;</a>
<a name="ln402">	}</a>
<a name="ln403"> </a>
<a name="ln404">	mvar_tracking_init();</a>
<a name="ln405"> </a>
<a name="ln406">	int killed = mvar_kill_tracked_children();</a>
<a name="ln407">	kernel_mvar_destroy();</a>
<a name="ln408">	mvar_reset_tracking();</a>
<a name="ln409"> </a>
<a name="ln410">	printf(&quot;mvar-close: terminated %d processes and released the kernel MVar\n&quot;, killed);</a>
<a name="ln411">	return 0;</a>
<a name="ln412">}</a>
</code></pre>
<div class="balloon" rel="49"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'nR' variable.</p></div>
<div class="balloon" rel="50"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'nW' variable.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>