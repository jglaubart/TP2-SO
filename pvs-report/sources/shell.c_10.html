<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>shell.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3">#include &quot;shell.h&quot;</a>
<a name="ln4"> </a>
<a name="ln5">#include &lt;stdint.h&gt;</a>
<a name="ln6">#include &lt;stdio.h&gt;</a>
<a name="ln7">#include &lt;string.h&gt;</a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;commands.h&quot;</a>
<a name="ln10">#include &lt;sys.h&gt;</a>
<a name="ln11">#include &lt;syscalls.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#ifdef ANSI_4_BIT_COLOR_SUPPORT</a>
<a name="ln14">#include &lt;ansiColors.h&gt;</a>
<a name="ln15">#endif</a>
<a name="ln16"> </a>
<a name="ln17">#define SHELL_PROMPT &quot;\e[0mshell \e[0;32m$\e[0m &quot;</a>
<a name="ln18">#define INPUT_CAPACITY 1024</a>
<a name="ln19">#define HISTORY_LIMIT 10</a>
<a name="ln20">#define MAX_PIPE_SEGMENTS 8</a>
<a name="ln21">#define MAX_ARGUMENTS 16</a>
<a name="ln22">#define SHELL_CTRL_K_CHAR 0x0B</a>
<a name="ln23"> </a>
<a name="ln24">typedef struct {</a>
<a name="ln25">	Command *command;</a>
<a name="ln26">	char *argv[MAX_ARGUMENTS];</a>
<a name="ln27">	int argc;</a>
<a name="ln28">	uint8_t background;</a>
<a name="ln29">	int32_t pid;</a>
<a name="ln30">} CommandInvocation;</a>
<a name="ln31"> </a>
<a name="ln32">static char input_line[INPUT_CAPACITY];</a>
<a name="ln33">static int input_length = 0;</a>
<a name="ln34"> </a>
<a name="ln35">static char history_entries[HISTORY_LIMIT][INPUT_CAPACITY];</a>
<a name="ln36">static int history_size = 0;</a>
<a name="ln37">static int history_cursor = 0;</a>
<a name="ln38">static int history_replay_remaining = 0;</a>
<a name="ln39"> </a>
<a name="ln40">static int exit_requested = 0;</a>
<a name="ln41">static int exit_status = 0;</a>
<a name="ln42"> </a>
<a name="ln43">static void show_prompt(void);</a>
<a name="ln44">static int capture_line(void);</a>
<a name="ln45">static void reset_input_buffer(void);</a>
<a name="ln46">static void remember_command(const char *line);</a>
<a name="ln47">static void copy_line(char *dest, const char *src, int capacity);</a>
<a name="ln48">static Command *find_command(const char *name);</a>
<a name="ln49">static int parse_commands(char *line, CommandInvocation *calls, int *count, char **unknown);</a>
<a name="ln50">static int run_pipeline(CommandInvocation *calls, int count, int pipeline_background);</a>
<a name="ln51">static void reset_invocation(CommandInvocation *invocation);</a>
<a name="ln52">static int is_whitespace_char(char c);</a>
<a name="ln53">static int strings_match(const char *a, const char *b);</a>
<a name="ln54"> </a>
<a name="ln55">static void recall_previous(enum REGISTERABLE_KEYS scancode);</a>
<a name="ln56">static void recall_next(enum REGISTERABLE_KEYS scancode);</a>
<a name="ln57">static void handle_backspace(enum REGISTERABLE_KEYS scancode);</a>
<a name="ln58">static void handle_mvar_close_hotkey(void);</a>
<a name="ln59"> </a>
<a name="ln60">int history(int argc, char **argv);</a>
<a name="ln61">int _getPid(int argc, char **argv);</a>
<a name="ln62"> </a>
<a name="ln63">Command commands[] = {</a>
<a name="ln64">	{.name = &quot;block&quot;, .function = _block, .description = &quot;Toggles a process between ready and blocked: block &lt;pid&gt;&quot;, .is_builtin = 0},</a>
<a name="ln65">	{.name = &quot;cat&quot;, .function = _cat, .description = &quot;Prints stdin exactly as received&quot;, .is_builtin = 0},</a>
<a name="ln66">    {.name = &quot;clear&quot;, .function = _clear, .description = &quot;Clears the screen&quot;, .is_builtin = 0},</a>
<a name="ln67">	{.name = &quot;divzero&quot;, .function = _exception_divzero, .description = &quot;Generates a division by zero exception&quot;, .is_builtin = 0},</a>
<a name="ln68">	{.name = &quot;echo&quot;, .function = _echo, .description = &quot;Prints the provided arguments&quot;, .is_builtin = 0},</a>
<a name="ln69">	{.name = &quot;filter&quot;, .function = _filter, .description = &quot;Removes vowels from stdin&quot;, .is_builtin = 0},</a>
<a name="ln70">	{.name = &quot;font&quot;, .function = _font, .description = &quot;Adjusts font size&quot;, .is_builtin = 0},</a>
<a name="ln71">    {.name = &quot;getpid&quot;, .function = _getPid, .description = &quot;Gets the current process ID&quot;, .is_builtin = 1},</a>
<a name="ln72">	{.name = &quot;help&quot;, .function = _help, .description = &quot;Shows the available commands&quot;, .is_builtin = 0},</a>
<a name="ln73">	{.name = &quot;history&quot;, .function = history, .description = &quot;Prints the command history&quot;, .is_builtin = 1},</a>
<a name="ln74">	{.name = &quot;invop&quot;, .function = _exception_invop, .description = &quot;Generates an invalid opcode exception&quot;, .is_builtin = 0},</a>
<a name="ln75">	{.name = &quot;kill&quot;, .function = _shell_kill, .description = &quot;Terminates the provided PID&quot;, .is_builtin = 0},</a>
<a name="ln76">	{.name = &quot;loop&quot;, .function = _loop, .description = &quot;Prints a message every specified ms&quot;, .is_builtin = 0},</a>
<a name="ln77">	{.name = &quot;man&quot;, .function = _man, .description = &quot;Shows the manual for a command&quot;, .is_builtin = 0},</a>
<a name="ln78">	{.name = &quot;mem&quot;, .function = _mem_stats, .description = &quot;Displays memory statistics&quot;, .is_builtin = 0},</a>
<a name="ln79">    {.name = &quot;mvar&quot;, .function = _mvar, .description = &quot;Creates a multi-variable process&quot;, .is_builtin = 0},</a>
<a name="ln80">    {.name = &quot;mvar-close&quot;, .function = _mvar_close, .description = &quot;Kills mvar processes (Ctrl+K)&quot;, .is_builtin = 0},</a>
<a name="ln81">	{.name = &quot;nice&quot;, .function = _nice, .description = &quot;Changes a process priority: nice &lt;pid&gt; &lt;priority&gt;&quot;, .is_builtin = 0},</a>
<a name="ln82">	{.name = &quot;ps&quot;, .function = _ps, .description = &quot;Lists active processes&quot;, .is_builtin = 0},</a>
<a name="ln83">	{.name = &quot;regs&quot;, .function = _regs, .description = &quot;Prints the last register snapshot&quot;, .is_builtin = 0},</a>
<a name="ln84">	{.name = &quot;snake&quot;, .function = _snake, .description = &quot;Launches the snake game&quot;, .is_builtin = 0},</a>
<a name="ln85">	{.name = &quot;test_mm&quot;, .function = _test_mm, .description = &quot;Stress tests the memory manager: test_mm &lt;max_memory&gt;&quot;, .is_builtin = 0},</a>
<a name="ln86">	{.name = &quot;test_prio&quot;, .function = _test_prio, .description = &quot;Spawns processes with different priorities: test_prio &lt;max_value&gt;&quot;, .is_builtin = 0},</a>
<a name="ln87">	{.name = &quot;test_processes&quot;, .function = _test_processes, .description = &quot;Creates and kills processes randomly: test_processes &lt;max_processes&gt;&quot;, .is_builtin = 0},</a>
<a name="ln88">	{.name = &quot;test_sync&quot;, .function = _test_sync, .description = &quot;Synchronization race test: test_sync &lt;iterations&gt; &lt;use_semaphore:0|1&gt;&quot;, .is_builtin = 0},</a>
<a name="ln89">	{.name = &quot;test_wait_children&quot;, .function = _test_wait_children, .description = &quot;Spawns children and waits for all: test_wait_children [child_count]&quot;, .is_builtin = 0},</a>
<a name="ln90">	{.name = &quot;time&quot;, .function = _time, .description = &quot;Displays the current time&quot;, .is_builtin = 0},</a>
<a name="ln91">	{.name = &quot;wc&quot;, .function = _wc, .description = &quot;Counts stdin lines&quot;, .is_builtin = 0},</a>
<a name="ln92">};</a>
<a name="ln93"> </a>
<a name="ln94">const int commands_size = sizeof(commands) / sizeof(commands[0]);</a>
<a name="ln95"> </a>
<a name="ln96">int main(void) {</a>
<a name="ln97">	registerKey(KP_UP_KEY, recall_previous);</a>
<a name="ln98">	registerKey(KP_DOWN_KEY, recall_next);</a>
<a name="ln99">	registerKey(BACKSPACE_KEY, handle_backspace);</a>
<a name="ln100"> </a>
<a name="ln101">	while (!exit_requested) {</a>
<a name="ln102">		show_prompt();</a>
<a name="ln103">		history_cursor = history_size;</a>
<a name="ln104"> </a>
<a name="ln105">		if (capture_line() &lt; 0) {</a>
<a name="ln106">			reset_input_buffer();</a>
<a name="ln107">			continue;</a>
<a name="ln108">		}</a>
<a name="ln109"> </a>
<a name="ln110">		char original_line[INPUT_CAPACITY];</a>
<a name="ln111">		copy_line(original_line, input_line, INPUT_CAPACITY);</a>
<a name="ln112"> </a>
<a name="ln113">		int only_whitespace = 1;</a>
<a name="ln114">		for (int i = 0; original_line[i] != '\0'; i++) {</a>
<a name="ln115">			if (!is_whitespace_char(original_line[i])) {</a>
<a name="ln116">				only_whitespace = 0;</a>
<a name="ln117">				break;</a>
<a name="ln118">			}</a>
<a name="ln119">		}</a>
<a name="ln120"> </a>
<a name="ln121">		if (only_whitespace) {</a>
<a name="ln122">			reset_input_buffer();</a>
<a name="ln123">			continue;</a>
<a name="ln124">		}</a>
<a name="ln125"> </a>
<a name="ln126">		CommandInvocation pipeline[MAX_PIPE_SEGMENTS];</a>
<a name="ln127">		for (int i = 0; i &lt; MAX_PIPE_SEGMENTS; i++) {</a>
<a name="ln128">			reset_invocation(&amp;pipeline[i]);</a>
<a name="ln129">		}</a>
<a name="ln130"> </a>
<a name="ln131">		int command_count = 0;</a>
<a name="ln132">		char *unknown = NULL;</a>
<a name="ln133">		int parse_status = parse_commands(input_line, pipeline, &amp;command_count, &amp;unknown);</a>
<a name="ln134"> </a>
<a name="ln135">		if (parse_status != 0) {</a>
<a name="ln136">			switch (parse_status) {</a>
<a name="ln137">				case -1:</a>
<a name="ln138">					fprintf(FD_STDERR, &quot;shell: too many commands chained with '|'\n&quot;);</a>
<a name="ln139">					break;</a>
<a name="ln140">				case -2:</a>
<a name="ln141">					if (unknown != NULL) {</a>
<a name="ln142">						fprintf(FD_STDERR, &quot;shell: too many arguments for '%s'\n&quot;, unknown);</a>
<a name="ln143">					} else {</a>
<a name="ln144">						fprintf(FD_STDERR, &quot;shell: too many arguments supplied\n&quot;);</a>
<a name="ln145">					}</a>
<a name="ln146">					break;</a>
<a name="ln147">				case -3:</a>
<a name="ln148">					fprintf(FD_STDERR, &quot;shell: syntax error near '|'\n&quot;);</a>
<a name="ln149">					break;</a>
<a name="ln150">				case -6:</a>
<a name="ln151">					fprintf(FD_STDERR, &quot;shell: cannot pipe more than two processes at once\n&quot;);</a>
<a name="ln152">					break;</a>
<a name="ln153">				case -4:</a>
<a name="ln154">					fprintf(FD_STDERR, &quot;shell: command not found: %s\n&quot;, unknown != NULL ? unknown : &quot;&quot;);</a>
<a name="ln155">					break;</a>
<a name="ln156">				default:</a>
<a name="ln157">					break;</a>
<a name="ln158">			}</a>
<a name="ln159">			reset_input_buffer();</a>
<a name="ln160">			continue;</a>
<a name="ln161">		}</a>
<a name="ln162"> </a>
<a name="ln163">		if (command_count == 0) {</a>
<a name="ln164">			reset_input_buffer();</a>
<a name="ln165">			continue;</a>
<a name="ln166">		}</a>
<a name="ln167"> </a>
<a name="ln168">		remember_command(original_line);</a>
<a name="ln169">		history_cursor = history_size;</a>
<a name="ln170"> </a>
<a name="ln171">		int last_background = pipeline[command_count - 1].background;</a>
<a name="ln172">		int invalid_background = 0;</a>
<a name="ln173">		for (int i = 0; i &lt; command_count - 1; i++) {</a>
<a name="ln174">			if (pipeline[i].background) {</a>
<a name="ln175">				invalid_background = 1;</a>
<a name="ln176">				break;</a>
<a name="ln177">			}</a>
<a name="ln178">		}</a>
<a name="ln179"> </a>
<a name="ln180">		if (invalid_background) {</a>
<a name="ln181">			fprintf(FD_STDERR, &quot;shell: only the last command in a pipeline can request background execution\n&quot;);</a>
<a name="ln182">			reset_input_buffer();</a>
<a name="ln183">			continue;</a>
<a name="ln184">		}</a>
<a name="ln185"> </a>
<a name="ln186">		int builtin_in_pipeline = 0;</a>
<a name="ln187">		for (int i = 0; i &lt; command_count; i++) {</a>
<a name="ln188">			if (pipeline[i].command-&gt;is_builtin) {</a>
<a name="ln189">				if (command_count &gt; 1) {</a>
<a name="ln190">					builtin_in_pipeline = 1;</a>
<a name="ln191">					break;</a>
<a name="ln192">				}</a>
<a name="ln193">				if (pipeline[i].background) {</a>
<a name="ln194">					fprintf(FD_STDERR, &quot;shell: builtin commands cannot run in background\n&quot;);</a>
<a name="ln195">					builtin_in_pipeline = 1;</a>
<a name="ln196">					break;</a>
<a name="ln197">				}</a>
<a name="ln198">			}</a>
<a name="ln199">		}</a>
<a name="ln200"> </a>
<a name="ln201">		if (builtin_in_pipeline) {</a>
<a name="ln202">			reset_input_buffer();</a>
<a name="ln203">			continue;</a>
<a name="ln204">		}</a>
<a name="ln205"> </a>
<a name="ln206">		if (command_count == 1 &amp;&amp; pipeline[0].command-&gt;is_builtin) {</a>
<a name="ln207">			pipeline[0].command-&gt;function(pipeline[0].argc, pipeline[0].argv);</a>
<a name="ln208">		} else {</a>
<a name="ln209">			if (run_pipeline(pipeline, command_count, last_background) != 0) {</a>
<a name="ln210">				fprintf(FD_STDERR, &quot;shell: failed to launch commands\n&quot;);</a>
<a name="ln211">			}</a>
<a name="ln212">		}</a>
<a name="ln213"> </a>
<a name="ln214">		reset_input_buffer();</a>
<a name="ln215">	}</a>
<a name="ln216"> </a>
<a name="ln217">	return exit_status;</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220">static void show_prompt(void) {</a>
<a name="ln221">	printf(&quot;%s&quot;, SHELL_PROMPT);</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">static void reset_input_buffer(void) {</a>
<a name="ln225">	input_line[0] = '\0';</a>
<a name="ln226">	input_length = 0;</a>
<a name="ln227">	history_replay_remaining = 0;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">static int capture_line(void) {</a>
<a name="ln231">	int ch = 0;</a>
<a name="ln232">	input_length = 0;</a>
<a name="ln233">	history_replay_remaining = 0;</a>
<a name="ln234"> </a>
<a name="ln235">	while (input_length &lt; INPUT_CAPACITY - 1) {</a>
<a name="ln236">		ch = getchar();</a>
<a name="ln237"> </a>
<a name="ln238">		if (ch == SHELL_CTRL_K_CHAR) {</a>
<a name="ln239">			handle_mvar_close_hotkey();</a>
<a name="ln240">			continue;</a>
<a name="ln241">		}</a>
<a name="ln242"> </a>
<a name="ln243">		if (ch == -1) {</a>
<a name="ln244">			if (input_length == 0) {</a>
<a name="ln245">				putchar('\n');</a>
<a name="ln246">				return -1;</a>
<a name="ln247">			}</a>
<a name="ln248">			input_line[input_length] = '\0';</a>
<a name="ln249">			//putchar('\n');</a>
<a name="ln250">			return input_length;</a>
<a name="ln251">		}</a>
<a name="ln252"> </a>
<a name="ln253">		if (ch == '\n') {</a>
<a name="ln254">			break;</a>
<a name="ln255">		}</a>
<a name="ln256"> </a>
<a name="ln257">		if (history_replay_remaining &gt; 0) {</a>
<a name="ln258">			history_replay_remaining--;</a>
<a name="ln259">			continue;</a>
<a name="ln260">		}</a>
<a name="ln261"> </a>
<a name="ln262">		if (ch &lt; 0) {</a>
<a name="ln263">			continue;</a>
<a name="ln264">		}</a>
<a name="ln265">		input_line[input_length++] = (char)ch;</a>
<a name="ln266">	}</a>
<a name="ln267"> </a>
<a name="ln268">	if (ch != '\n') {</a>
<a name="ln269">		fprintf(FD_STDERR, &quot;\nShell input overflow\n&quot;);</a>
<a name="ln270">		do {</a>
<a name="ln271">			ch = getchar();</a>
<a name="ln272">		} while (ch != '\n' &amp;&amp; ch &gt;= 0);</a>
<a name="ln273">		return -1;</a>
<a name="ln274">	}</a>
<a name="ln275"> </a>
<a name="ln276">	putchar('\n');</a>
<a name="ln277">	input_line[input_length] = '\0';</a>
<a name="ln278">	return input_length;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">static void remember_command(const char *line) {</a>
<a name="ln282">	if (line == NULL || *line == '\0') {</a>
<a name="ln283">		return;</a>
<a name="ln284">	}</a>
<a name="ln285">	if (history_size &lt; HISTORY_LIMIT) {</a>
<a name="ln286">		copy_line(history_entries[history_size], line, INPUT_CAPACITY);</a>
<a name="ln287">		history_size++;</a>
<a name="ln288">	} else {</a>
<a name="ln289">		for (int i = 1; i &lt; HISTORY_LIMIT; i++) {</a>
<a name="ln290">			copy_line(history_entries[i - 1], history_entries[i], INPUT_CAPACITY);</a>
<a name="ln291">		}</a>
<a name="ln292">		copy_line(history_entries[HISTORY_LIMIT - 1], line, INPUT_CAPACITY);</a>
<a name="ln293">	}</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">static Command *find_command(const char *name) {</a>
<a name="ln297">	if (name == NULL) {</a>
<a name="ln298">		return NULL;</a>
<a name="ln299">	}</a>
<a name="ln300">	for (int i = 0; i &lt; commands_size; i++) {</a>
<a name="ln301">		if (strings_match(commands[i].name, name)) {</a>
<a name="ln302">			return &amp;commands[i];</a>
<a name="ln303">		}</a>
<a name="ln304">	}</a>
<a name="ln305">	return NULL;</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">static int parse_commands(char *line, CommandInvocation *calls, int *count, char **unknown) {</a>
<a name="ln309">	if (line == NULL || calls == NULL || count == NULL) {</a>
<a name="ln310">		return -5;</a>
<a name="ln311">	}</a>
<a name="ln312"> </a>
<a name="ln313">	*unknown = NULL;</a>
<a name="ln314">	int stages = 0;</a>
<a name="ln315">	int pipe_count = 0;</a>
<a name="ln316">	char *segment_ptr = line;</a>
<a name="ln317"> </a>
<a name="ln318">	while (segment_ptr != NULL) {</a>
<a name="ln319">		if (stages &gt;= MAX_PIPE_SEGMENTS) {</a>
<a name="ln320">			return -1;</a>
<a name="ln321">		}</a>
<a name="ln322"> </a>
<a name="ln323">		char *segment_start = segment_ptr;</a>
<a name="ln324">		char *pipe_pos = NULL;</a>
<a name="ln325">		for (char *scan = segment_start; scan != NULL &amp;&amp; *scan != '\0'; scan++) {</a>
<a name="ln326">			if (*scan == '|') {</a>
<a name="ln327">				pipe_pos = scan;</a>
<a name="ln328">				break;</a>
<a name="ln329">			}</a>
<a name="ln330">		}</a>
<a name="ln331"> </a>
<a name="ln332">		char *next_segment = NULL;</a>
<a name="ln333">		if (pipe_pos != NULL) {</a>
<a name="ln334">			if (pipe_count &gt;= 1) {</a>
<a name="ln335">				return -6;</a>
<a name="ln336">			}</a>
<a name="ln337">			pipe_count++;</a>
<a name="ln338">			*pipe_pos = '\0';</a>
<a name="ln339">			next_segment = pipe_pos + 1;</a>
<a name="ln340">		}</a>
<a name="ln341"> </a>
<a name="ln342">		while (*segment_start != '\0' &amp;&amp; is_whitespace_char(*segment_start)) {</a>
<a name="ln343">			segment_start++;</a>
<a name="ln344">		}</a>
<a name="ln345"> </a>
<a name="ln346">		char *segment_end = segment_start + strlen(segment_start);</a>
<a name="ln347">		while (segment_end &gt; segment_start &amp;&amp; is_whitespace_char(*(segment_end - 1))) {</a>
<a name="ln348">			segment_end--;</a>
<a name="ln349">		}</a>
<a name="ln350">		*segment_end = '\0';</a>
<a name="ln351"> </a>
<a name="ln352">		if (*segment_start == '\0') {</a>
<a name="ln353">			return -3;</a>
<a name="ln354">		}</a>
<a name="ln355"> </a>
<a name="ln356">		CommandInvocation *current = &amp;calls[stages];</a>
<a name="ln357">		reset_invocation(current);</a>
<a name="ln358"> </a>
<a name="ln359">		char *token = strtok(segment_start, &quot; &quot;);</a>
<a name="ln360">		while (token != NULL) {</a>
<a name="ln361">			if (current-&gt;argc &gt;= MAX_ARGUMENTS - 1) {</a>
<a name="ln362">				*unknown = current-&gt;argc &gt; 0 ? current-&gt;argv[0] : NULL;</a>
<a name="ln363">				return -2;</a>
<a name="ln364">			}</a>
<a name="ln365">			current-&gt;argv[current-&gt;argc++] = token;</a>
<a name="ln366">			token = strtok(NULL, &quot; &quot;);</a>
<a name="ln367">		}</a>
<a name="ln368"> </a>
<a name="ln369">		if (current-&gt;argc == 0) {</a>
<a name="ln370">			return -3;</a>
<a name="ln371">		}</a>
<a name="ln372"> </a>
<a name="ln373">		char *last = current-&gt;argv[current-&gt;argc - 1];</a>
<a name="ln374">		size_t last_len = strlen(last);</a>
<a name="ln375">		if (strcmp(last, &quot;&amp;&quot;) == 0) {</a>
<a name="ln376">			current-&gt;argv[current-&gt;argc - 1] = NULL;</a>
<a name="ln377">			current-&gt;argc--;</a>
<a name="ln378">			current-&gt;background = 1;</a>
<a name="ln379">		} else if (last_len &gt; 0 &amp;&amp; last[last_len - 1] == '&amp;') {</a>
<a name="ln380">			current-&gt;background = 1;</a>
<a name="ln381">			while (last_len &gt; 0 &amp;&amp; last[last_len - 1] == '&amp;') {</a>
<a name="ln382">				last[--last_len] = '\0';</a>
<a name="ln383">			}</a>
<a name="ln384">			if (last_len == 0) {</a>
<a name="ln385">				current-&gt;argc--;</a>
<a name="ln386">			}</a>
<a name="ln387">		}</a>
<a name="ln388"> </a>
<a name="ln389">		if (current-&gt;argc == 0) {</a>
<a name="ln390">			return -3;</a>
<a name="ln391">		}</a>
<a name="ln392"> </a>
<a name="ln393">		current-&gt;argv[current-&gt;argc] = NULL;</a>
<a name="ln394">		current-&gt;command = find_command(current-&gt;argv[0]);</a>
<a name="ln395">		if (current-&gt;command == NULL) {</a>
<a name="ln396">			*unknown = current-&gt;argv[0];</a>
<a name="ln397">			return -4;</a>
<a name="ln398">		}</a>
<a name="ln399"> </a>
<a name="ln400">		current-&gt;pid = -1;</a>
<a name="ln401"> </a>
<a name="ln402">		stages++;</a>
<a name="ln403">		segment_ptr = next_segment;</a>
<a name="ln404">	}</a>
<a name="ln405"> </a>
<a name="ln406">	*count = stages;</a>
<a name="ln407">	return 0;</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">static int run_pipeline(CommandInvocation *calls, int count, int pipeline_background) {</a>
<a name="ln411">	int32_t spawned_pids[MAX_PIPE_SEGMENTS];</a>
<a name="ln412">	int pid_count = 0;</a>
<a name="ln413">	int pending_pipe = -1;</a>
<a name="ln414"> </a>
<a name="ln415">	for (int i = 0; i &lt; count; i++) {</a>
<a name="ln416">		CommandInvocation *current = &amp;calls[i];</a>
<a name="ln417">		int is_last = (i == count - 1);</a>
<a name="ln418"> </a>
<a name="ln419">		if (current-&gt;command == NULL || current-&gt;command-&gt;is_builtin) {</a>
<a name="ln420">			continue;</a>
<a name="ln421">		}</a>
<a name="ln422"> </a>
<a name="ln423">		int pipefd[PIPE_FD_COUNT] = {-1, -1};</a>
<a name="ln424">		int next_pipe = -1;</a>
<a name="ln425">		if (!is_last) {</a>
<a name="ln426">			if (openPipe(pipefd) != 0) {</a>
<a name="ln427">				fprintf(FD_STDERR, &quot;shell: unable to create pipe\n&quot;);</a>
<a name="ln428">				return -1;</a>
<a name="ln429">			}</a>
<a name="ln430">			next_pipe = pipefd[READ_FD];</a>
<a name="ln431">		}</a>
<a name="ln432"> </a>
<a name="ln433">		int input_type = (pending_pipe &gt;= 0) ? PIPE_ENDPOINT_PIPE : PIPE_ENDPOINT_CONSOLE;</a>
<a name="ln434">		int input_target = (pending_pipe &gt;= 0) ? pending_pipe : -1;</a>
<a name="ln435">		if (setFdTarget(READ_FD, input_type, input_target) != 0) {</a>
<a name="ln436">			fprintf(FD_STDERR, &quot;shell: unable to configure stdin\n&quot;);</a>
<a name="ln437">			setFdTarget(READ_FD, PIPE_ENDPOINT_CONSOLE, -1);</a>
<a name="ln438">			return -1;</a>
<a name="ln439">		}</a>
<a name="ln440"> </a>
<a name="ln441">		int output_type = (next_pipe &gt;= 0) ? PIPE_ENDPOINT_PIPE : PIPE_ENDPOINT_CONSOLE;</a>
<a name="ln442">		int output_target = (next_pipe &gt;= 0) ? next_pipe : -1;</a>
<a name="ln443">		if (setFdTarget(WRITE_FD, output_type, output_target) != 0) {</a>
<a name="ln444">			fprintf(FD_STDERR, &quot;shell: unable to configure stdout\n&quot;);</a>
<a name="ln445">			setFdTarget(READ_FD, PIPE_ENDPOINT_CONSOLE, -1);</a>
<a name="ln446">			setFdTarget(WRITE_FD, PIPE_ENDPOINT_CONSOLE, -1);</a>
<a name="ln447">			return -1;</a>
<a name="ln448">		}</a>
<a name="ln449"> </a>
<a name="ln450">		uint8_t run_in_background = pipeline_background ? 1 : (is_last ? 0 : 1);</a>
<a name="ln451">		int32_t pid = createProcess((void *)current-&gt;command-&gt;function, current-&gt;argc, (uint8_t **)current-&gt;argv, run_in_background);</a>
<a name="ln452">		setFdTarget(READ_FD, PIPE_ENDPOINT_CONSOLE, -1);</a>
<a name="ln453">		setFdTarget(WRITE_FD, PIPE_ENDPOINT_CONSOLE, -1);</a>
<a name="ln454"> </a>
<a name="ln455">		if (pid &lt; 0) {</a>
<a name="ln456">			fprintf(FD_STDERR, &quot;shell: unable to create process for '%s'\n&quot;, current-&gt;command-&gt;name);</a>
<a name="ln457">			return -1;</a>
<a name="ln458">		}</a>
<a name="ln459"> </a>
<a name="ln460">		spawned_pids[pid_count++] = pid;</a>
<a name="ln461">		current-&gt;pid = pid;</a>
<a name="ln462">		pending_pipe = next_pipe;</a>
<a name="ln463">	}</a>
<a name="ln464"> </a>
<a name="ln465">	if (!pipeline_background) {</a>
<a name="ln466">		int upstream_signaled = 0;</a>
<a name="ln467">		for (int i = pid_count - 1; i &gt;= 0; i--) {</a>
<a name="ln468">			int32_t pid = spawned_pids[i];</a>
<a name="ln469">			if (pid &lt;= 0) {</a>
<a name="ln470">				continue;</a>
<a name="ln471">			}</a>
<a name="ln472">			waitPid(pid);</a>
<a name="ln473">			if (!upstream_signaled &amp;&amp; i == pid_count - 1) {</a>
<a name="ln474">				for (int j = 0; j &lt; i; j++) {</a>
<a name="ln475">					if (spawned_pids[j] &gt; 0) {</a>
<a name="ln476">						kill(spawned_pids[j]);</a>
<a name="ln477">					}</a>
<a name="ln478">				}</a>
<a name="ln479">				upstream_signaled = 1;</a>
<a name="ln480">			}</a>
<a name="ln481">		}</a>
<a name="ln482">	}</a>
<a name="ln483"> </a>
<a name="ln484">	return 0;</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487">static void copy_line(char *dest, const char *src, int capacity) {</a>
<a name="ln488">	if (dest == NULL || src == NULL || capacity &lt;= 0) {</a>
<a name="ln489">		return;</a>
<a name="ln490">	}</a>
<a name="ln491">	int i = 0;</a>
<a name="ln492">	while (i &lt; capacity - 1 &amp;&amp; src[i] != '\0') {</a>
<a name="ln493">		dest[i] = src[i];</a>
<a name="ln494">		i++;</a>
<a name="ln495">	}</a>
<a name="ln496">	dest[i] = '\0';</a>
<a name="ln497">	i++;</a>
<a name="ln498">	while (i &lt; capacity) {</a>
<a name="ln499">		dest[i++] = '\0';</a>
<a name="ln500">	}</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">static void recall_previous(enum REGISTERABLE_KEYS scancode) {</a>
<a name="ln504">	if (history_size == 0) {</a>
<a name="ln505">		return;</a>
<a name="ln506">	}</a>
<a name="ln507">	if (history_cursor &gt; 0) {</a>
<a name="ln508">		history_cursor--;</a>
<a name="ln509">	}</a>
<a name="ln510">	clearInputBuffer();</a>
<a name="ln511">	reset_input_buffer();</a>
<a name="ln512">	const char *entry = history_entries[history_cursor];</a>
<a name="ln513">	int len = strlen(entry);</a>
<a name="ln514">	if (len &gt; 0) {</a>
<a name="ln515">		int max_copy = len &lt; INPUT_CAPACITY - 1 ? len : INPUT_CAPACITY - 1;</a>
<a name="ln516">		copy_line(input_line, entry, INPUT_CAPACITY);</a>
<a name="ln517">		input_length = max_copy;</a>
<a name="ln518">		input_line[input_length] = '\0';</a>
<a name="ln519">		history_replay_remaining = input_length;</a>
<a name="ln520">		sys_write(FD_STDIN, input_line, input_length);</a>
<a name="ln521">	}</a>
<a name="ln522">}</a>
<a name="ln523"> </a>
<a name="ln524">static void recall_next(enum REGISTERABLE_KEYS scancode) {</a>
<a name="ln525">	if (history_size == 0) {</a>
<a name="ln526">		return;</a>
<a name="ln527">	}</a>
<a name="ln528">	if (history_cursor &lt; history_size - 1) {</a>
<a name="ln529">		history_cursor++;</a>
<a name="ln530">		clearInputBuffer();</a>
<a name="ln531">		reset_input_buffer();</a>
<a name="ln532">		const char *entry = history_entries[history_cursor];</a>
<a name="ln533">		int len = strlen(entry);</a>
<a name="ln534">		if (len &gt; 0) {</a>
<a name="ln535">			int max_copy = len &lt; INPUT_CAPACITY - 1 ? len : INPUT_CAPACITY - 1;</a>
<a name="ln536">			copy_line(input_line, entry, INPUT_CAPACITY);</a>
<a name="ln537">			input_length = max_copy;</a>
<a name="ln538">			input_line[input_length] = '\0';</a>
<a name="ln539">			history_replay_remaining = input_length;</a>
<a name="ln540">			sys_write(FD_STDIN, input_line, input_length);</a>
<a name="ln541">		}</a>
<a name="ln542">	} else {</a>
<a name="ln543">		history_cursor = history_size;</a>
<a name="ln544">		clearInputBuffer();</a>
<a name="ln545">		reset_input_buffer();</a>
<a name="ln546">	}</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">static void reset_invocation(CommandInvocation *invocation) {</a>
<a name="ln550">	if (invocation == NULL) {</a>
<a name="ln551">		return;</a>
<a name="ln552">	}</a>
<a name="ln553">	invocation-&gt;command = NULL;</a>
<a name="ln554">	invocation-&gt;argc = 0;</a>
<a name="ln555">	invocation-&gt;background = 0;</a>
<a name="ln556">	invocation-&gt;pid = -1;</a>
<a name="ln557">	for (int i = 0; i &lt; MAX_ARGUMENTS; i++) {</a>
<a name="ln558">		invocation-&gt;argv[i] = NULL;</a>
<a name="ln559">	}</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">static int is_whitespace_char(char c) {</a>
<a name="ln563">	return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f' || c == '\v';</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">static int strings_match(const char *a, const char *b) {</a>
<a name="ln567">	if (a == NULL || b == NULL) {</a>
<a name="ln568">		return 0;</a>
<a name="ln569">	}</a>
<a name="ln570">	while (*a != '\0' &amp;&amp; *b != '\0') {</a>
<a name="ln571">		if (*a != *b) {</a>
<a name="ln572">			return 0;</a>
<a name="ln573">		}</a>
<a name="ln574">		a++;</a>
<a name="ln575">		b++;</a>
<a name="ln576">	}</a>
<a name="ln577">	return *a == '\0' &amp;&amp; *b == '\0';</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">static void handle_backspace(enum REGISTERABLE_KEYS scancode) {</a>
<a name="ln581">	if (input_length &gt; 0) {</a>
<a name="ln582">		input_length--;</a>
<a name="ln583">		input_line[input_length] = '\0';</a>
<a name="ln584">		if (history_replay_remaining &gt; 0) {</a>
<a name="ln585">			history_replay_remaining--;</a>
<a name="ln586">		}</a>
<a name="ln587">	}</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">static void handle_mvar_close_hotkey(void) {</a>
<a name="ln591">	putchar('\n');</a>
<a name="ln592">	reset_input_buffer();</a>
<a name="ln593">	char *argv[] = {&quot;mvar-close&quot;, NULL};</a>
<a name="ln594">	_mvar_close(1, argv);</a>
<a name="ln595">	show_prompt();</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598">int history(int argc, char **argv) {</a>
<a name="ln599">	if (argc != 1) {</a>
<a name="ln600">		fprintf(FD_STDERR, &quot;Usage: history\n&quot;);</a>
<a name="ln601">		return 1;</a>
<a name="ln602">	}</a>
<a name="ln603"> </a>
<a name="ln604">	for (int i = history_size - 1, idx = 0; i &gt;= 0; i--, idx++) {</a>
<a name="ln605">		printf(&quot;%d. %s\n&quot;, idx, history_entries[i]);</a>
<a name="ln606">	}</a>
<a name="ln607">	return 0;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">int _getPid(int argc, char **argv) {</a>
<a name="ln611">    int pid = getPid();</a>
<a name="ln612">    printf(&quot;Current process ID: %d\n&quot;, pid);</a>
<a name="ln613">    return 0;</a>
<a name="ln614">}</a>
</code></pre>
<div class="balloon" rel="362"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'current-&gt;argc &gt; 0' is always true.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>