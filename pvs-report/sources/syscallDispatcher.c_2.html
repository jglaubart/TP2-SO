<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>syscallDispatcher.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;syscallDispatcher.h&gt;</a>
<a name="ln5">#include &lt;stddef.h&gt;</a>
<a name="ln6">#include &lt;sound.h&gt;</a>
<a name="ln7">#include &lt;keyboard.h&gt;</a>
<a name="ln8">#include &lt;fonts.h&gt;</a>
<a name="ln9">#include &lt;lib.h&gt;</a>
<a name="ln10">#include &lt;video.h&gt;</a>
<a name="ln11">#include &lt;time.h&gt;</a>
<a name="ln12">#include &lt;memory.h&gt;</a>
<a name="ln13">#include &lt;process.h&gt;</a>
<a name="ln14">#include &lt;scheduler.h&gt;</a>
<a name="ln15">#include &lt;pipes.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#ifndef FD_STDIN</a>
<a name="ln18">#define FD_STDIN  0</a>
<a name="ln19">#define FD_STDOUT 1</a>
<a name="ln20">#define FD_STDERR 2</a>
<a name="ln21">#endif</a>
<a name="ln22"> </a>
<a name="ln23"> </a>
<a name="ln24">extern int64_t register_snapshot[18];</a>
<a name="ln25">extern int64_t register_snapshot_taken;</a>
<a name="ln26"> </a>
<a name="ln27">// @todo Note: Technically.. registers on the stack are modifiable (since its a struct pointer, not struct). </a>
<a name="ln28">int32_t syscallDispatcher(Registers * registers) {</a>
<a name="ln29">	switch(registers-&gt;rax){</a>
<a name="ln30">		case 3: return sys_read(registers-&gt;rdi, (signed char *) registers-&gt;rsi, registers-&gt;rdx);</a>
<a name="ln31">		// Note: Register parameters are 64-bit</a>
<a name="ln32">		case 4: return sys_write(registers-&gt;rdi, (char *) registers-&gt;rsi, registers-&gt;rdx);</a>
<a name="ln33">		</a>
<a name="ln34">		case 0x80000000: return sys_start_beep(registers-&gt;rdi);</a>
<a name="ln35">		case 0x80000001: return sys_stop_beep();</a>
<a name="ln36">		case 0x80000002: return sys_fonts_text_color(registers-&gt;rdi);</a>
<a name="ln37">		case 0x80000003: return sys_fonts_background_color(registers-&gt;rdi);</a>
<a name="ln38">		case 0x80000004: /* Reserved for sys_set_italics */</a>
<a name="ln39">		case 0x80000005: /* Reserved for sys_set_bold */</a>
<a name="ln40">		case 0x80000006: /* Reserved for sys_set_underline */</a>
<a name="ln41">			return -1;</a>
<a name="ln42">		case 0x80000007: return sys_fonts_decrease_size();</a>
<a name="ln43">		case 0x80000008: return sys_fonts_increase_size();</a>
<a name="ln44">		case 0x80000009: return sys_fonts_set_size((uint8_t) registers-&gt;rdi);</a>
<a name="ln45">		case 0x8000000A: return sys_clear_screen();</a>
<a name="ln46">		case 0x8000000B: return sys_clear_input_buffer();</a>
<a name="ln47"> </a>
<a name="ln48">		case 0x80000010: return sys_hour((int *) registers-&gt;rdi);</a>
<a name="ln49">		case 0x80000011: return sys_minute((int *) registers-&gt;rdi);</a>
<a name="ln50">		case 0x80000012: return sys_second((int *) registers-&gt;rdi);</a>
<a name="ln51"> </a>
<a name="ln52">		case 0x80000019: return sys_circle(registers-&gt;rdi, registers-&gt;rsi, registers-&gt;rdx, registers-&gt;rcx);</a>
<a name="ln53">		case 0x80000020: return sys_rectangle(registers-&gt;rdi, registers-&gt;rsi, registers-&gt;rdx, registers-&gt;rcx, registers-&gt;r8);</a>
<a name="ln54">		case 0x80000021: return sys_fill_video_memory(registers-&gt;rdi);</a>
<a name="ln55"> </a>
<a name="ln56">		case 0x800000A0: return sys_exec((int (*)(void)) registers-&gt;rdi);</a>
<a name="ln57"> </a>
<a name="ln58">		case 0x800000B0: return sys_register_key((uint8_t) registers-&gt;rdi, (SpecialKeyHandler) registers-&gt;rsi);</a>
<a name="ln59"> </a>
<a name="ln60">		case 0x800000C0: return sys_window_width();</a>
<a name="ln61">		case 0x800000C1: return sys_window_height();</a>
<a name="ln62"> </a>
<a name="ln63">		case 0x800000D0: return sys_sleep_milis(registers-&gt;rdi);</a>
<a name="ln64"> </a>
<a name="ln65">		case 0x800000E0: return sys_get_register_snapshot((int64_t *) registers-&gt;rdi);</a>
<a name="ln66"> </a>
<a name="ln67">		case 0x800000F0: return sys_get_character_without_display();</a>
<a name="ln68"> </a>
<a name="ln69">		case 0x80000100: return (int64_t) sys_malloc(registers-&gt;rdi);</a>
<a name="ln70">		case 0x80000101: return sys_free((void *) registers-&gt;rdi);</a>
<a name="ln71">		case 0x80000102: return sys_memstats((int *) registers-&gt;rdi, (int *) registers-&gt;rsi, (int *) registers-&gt;rdx);</a>
<a name="ln72"> </a>
<a name="ln73">		case 0x80000200: return sys_getpid();</a>
<a name="ln74">		case 0x80000201: return sys_create_process((uint8_t *) registers-&gt;rdi, registers-&gt;rsi, (char **) registers-&gt;rdx, (uint8_t) registers-&gt;rcx);</a>
<a name="ln75">		case 0x80000202: return sys_unblock((int) registers-&gt;rdi);</a>
<a name="ln76">		case 0x80000203: return sys_block((int) registers-&gt;rdi);</a>
<a name="ln77">		case 0x80000204: return sys_kill((int) registers-&gt;rdi);</a>
<a name="ln78">		case 0x80000205: return sys_ps((ProcessInformation *) registers-&gt;rdi);</a>
<a name="ln79">		case 0x80000206: return sys_nice((int) registers-&gt;rdi, (int) registers-&gt;rsi);</a>
<a name="ln80">		case 0x80000207: return sys_wait_pid((int) registers-&gt;rdi);</a>
<a name="ln81">		case 0x80000208: return sys_yield();</a>
<a name="ln82">		case 0x80000209: return sys_wait_children();</a>
<a name="ln83">		case 0x8000020A: return sys_get_process_info((int) registers-&gt;rdi, (ProcessInformation *) registers-&gt;rsi);</a>
<a name="ln84"> </a>
<a name="ln85">		case 0x80000300: return (int64_t)sys_sem_init((const char *) registers-&gt;rdi, (uint32_t) registers-&gt;rsi);</a>
<a name="ln86">		case 0x80000301: return sys_sem_post((semADT) registers-&gt;rdi);</a>
<a name="ln87">		case 0x80000302: return sys_sem_wait((semADT) registers-&gt;rdi);</a>
<a name="ln88">		case 0x80000303: return sys_sem_destroy((semADT) registers-&gt;rdi);</a>
<a name="ln89">		</a>
<a name="ln90">		case 0x80000400: return sys_pipe((int *) registers-&gt;rdi);</a>
<a name="ln91">		case 0x80000401: return sys_close_pipe((int) registers-&gt;rdi);</a>
<a name="ln92">		case 0x80000402: return sys_set_fd_target((int) registers-&gt;rdi, (PipeEndpointType) registers-&gt;rsi, (int) registers-&gt;rdx);</a>
<a name="ln93">		</a>
<a name="ln94">		default:</a>
<a name="ln95">            return 0;</a>
<a name="ln96">	}</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">// ==================================================================</a>
<a name="ln100">// Linux syscalls</a>
<a name="ln101">// ==================================================================</a>
<a name="ln102"> </a>
<a name="ln103">int32_t sys_write(int32_t fd, char * __user_buf, int32_t count) {</a>
<a name="ln104">    if (__user_buf == NULL || count &lt; 0) {</a>
<a name="ln105">        return -1;</a>
<a name="ln106">    }</a>
<a name="ln107"> </a>
<a name="ln108">    if (count == 0) {</a>
<a name="ln109">        return 0;</a>
<a name="ln110">    }</a>
<a name="ln111"> </a>
<a name="ln112">    if (fd == FD_STDIN) {</a>
<a name="ln113">        return printToFd(fd, __user_buf, count);</a>
<a name="ln114">    }</a>
<a name="ln115"> </a>
<a name="ln116">    if (fd != FD_STDOUT &amp;&amp; fd != FD_STDERR) {</a>
<a name="ln117">        return -1;</a>
<a name="ln118">    }</a>
<a name="ln119"> </a>
<a name="ln120">    Process *current = getCurrentProcess();</a>
<a name="ln121">    if (current == NULL) {</a>
<a name="ln122">        return -1;</a>
<a name="ln123">    }</a>
<a name="ln124"> </a>
<a name="ln125">    PipeEndpoint *endpoint = &amp;current-&gt;fds[WRITE_FD];</a>
<a name="ln126">    if (endpoint-&gt;type == PIPE_ENDPOINT_CONSOLE) {</a>
<a name="ln127">        return printToFd(fd, __user_buf, count);</a>
<a name="ln128">    }</a>
<a name="ln129"> </a>
<a name="ln130">    if (endpoint-&gt;type == PIPE_ENDPOINT_PIPE) {</a>
<a name="ln131">        return pipeWriteEndpoint(endpoint, (const uint8_t *)__user_buf, count);</a>
<a name="ln132">    }</a>
<a name="ln133"> </a>
<a name="ln134">    return -1;</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">int32_t sys_read(int32_t fd, signed char * __user_buf, int32_t count) {</a>
<a name="ln138">    if (__user_buf == NULL || count &lt; 0) {</a>
<a name="ln139">        return -1;</a>
<a name="ln140">    }</a>
<a name="ln141"> </a>
<a name="ln142">    if (count == 0) {</a>
<a name="ln143">        return 0;</a>
<a name="ln144">    }</a>
<a name="ln145"> </a>
<a name="ln146">    if (fd != FD_STDIN) {</a>
<a name="ln147">        return -1;</a>
<a name="ln148">    }</a>
<a name="ln149"> </a>
<a name="ln150">    Process *current = getCurrentProcess();</a>
<a name="ln151">    if (current == NULL) {</a>
<a name="ln152">        return -1;</a>
<a name="ln153">    }</a>
<a name="ln154"> </a>
<a name="ln155">    PipeEndpoint *endpoint = &amp;current-&gt;fds[READ_FD];</a>
<a name="ln156">    if (endpoint-&gt;type == PIPE_ENDPOINT_CONSOLE) {</a>
<a name="ln157">        int32_t i;</a>
<a name="ln158">        int8_t c;</a>
<a name="ln159">        for(i = 0; i &lt; count &amp;&amp; (c = getKeyboardCharacter(AWAIT_RETURN_KEY | SHOW_BUFFER_WHILE_TYPING)) != EOF; i++){</a>
<a name="ln160">            *(__user_buf + i) = c;</a>
<a name="ln161">        }</a>
<a name="ln162">        return i;</a>
<a name="ln163">    }</a>
<a name="ln164"> </a>
<a name="ln165">    if (endpoint-&gt;type == PIPE_ENDPOINT_PIPE) {</a>
<a name="ln166">        return pipeReadEndpoint(endpoint, (uint8_t *)__user_buf, count);</a>
<a name="ln167">    }</a>
<a name="ln168"> </a>
<a name="ln169">    return -1;</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">int32_t sys_pipe(int pipefd[2]) {</a>
<a name="ln173">    if (pipefd == NULL) {</a>
<a name="ln174">        return -1;</a>
<a name="ln175">    }</a>
<a name="ln176"> </a>
<a name="ln177">    int pipeID = openPipe();</a>
<a name="ln178">    if (pipeID &lt; 0) {</a>
<a name="ln179">        return -1;</a>
<a name="ln180">    }</a>
<a name="ln181"> </a>
<a name="ln182">    pipefd[READ_FD] = pipeID;</a>
<a name="ln183">    pipefd[WRITE_FD] = pipeID;</a>
<a name="ln184">    return 0;</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">int32_t sys_close_pipe(int pipeID) {</a>
<a name="ln188">    if (pipeID &lt; 0) {</a>
<a name="ln189">        return -1;</a>
<a name="ln190">    }</a>
<a name="ln191">    return pipeRelease(pipeID, PIPE_ROLE_NONE);</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">int32_t sys_set_fd_target(int fd, PipeEndpointType type, int pipeID) {</a>
<a name="ln195">    if (fd != READ_FD &amp;&amp; fd != WRITE_FD) {</a>
<a name="ln196">        return -1;</a>
<a name="ln197">    }</a>
<a name="ln198"> </a>
<a name="ln199">    Process *current = getCurrentProcess();</a>
<a name="ln200">    if (current == NULL) {</a>
<a name="ln201">        return -1;</a>
<a name="ln202">    }</a>
<a name="ln203"> </a>
<a name="ln204">    int status;</a>
<a name="ln205">    if (fd == READ_FD) {</a>
<a name="ln206">        status = pipeSetReadTarget(current-&gt;fds, type, pipeID);</a>
<a name="ln207">    } else {</a>
<a name="ln208">        status = pipeSetWriteTarget(current-&gt;fds, type, pipeID);</a>
<a name="ln209">    }</a>
<a name="ln210">    return status;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">// ==================================================================</a>
<a name="ln214">// Custom system calls</a>
<a name="ln215">// ==================================================================</a>
<a name="ln216"> </a>
<a name="ln217">int32_t sys_start_beep(uint32_t nFrequence) {</a>
<a name="ln218">	play_sound(nFrequence);</a>
<a name="ln219">	return 0;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">int32_t sys_stop_beep(void) {</a>
<a name="ln223">	setSpeaker(SPEAKER_OFF);</a>
<a name="ln224">	return 0;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">int32_t sys_fonts_text_color(uint32_t color) {</a>
<a name="ln228">	setTextColor(color);</a>
<a name="ln229">	return 0;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">int32_t sys_fonts_background_color(uint32_t color) {</a>
<a name="ln233">	setBackgroundColor(color);</a>
<a name="ln234">	return 0;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">int32_t sys_fonts_decrease_size(void) {</a>
<a name="ln238">	return decreaseFontSize();</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">int32_t sys_fonts_increase_size(void) {</a>
<a name="ln242">	return increaseFontSize();</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">int32_t sys_fonts_set_size(uint8_t size) {</a>
<a name="ln246">	return setFontSize(size);</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">int32_t sys_clear_screen(void) {</a>
<a name="ln250">	clear();</a>
<a name="ln251">	return 0;</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">int32_t sys_clear_input_buffer(void) {</a>
<a name="ln255">	while(clearBuffer() != 0);</a>
<a name="ln256">	return 0;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">uint16_t sys_window_width(void) {</a>
<a name="ln260">	return getWindowWidth();</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">uint16_t sys_window_height(void) {</a>
<a name="ln264">	return getWindowHeight();</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">// ==================================================================</a>
<a name="ln268">// Date system calls</a>
<a name="ln269">// ==================================================================</a>
<a name="ln270"> </a>
<a name="ln271">int32_t sys_hour(int * hour) {</a>
<a name="ln272">	*hour = getHour();</a>
<a name="ln273">	return 0;</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">int32_t sys_minute(int * minute) {</a>
<a name="ln277">	*minute = getMinute();</a>
<a name="ln278">	return 0;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">int32_t sys_second(int * second) {</a>
<a name="ln282">	*second = getSecond();</a>
<a name="ln283">	return 0;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">// ==================================================================</a>
<a name="ln287">// Draw system calls</a>
<a name="ln288">// ==================================================================</a>
<a name="ln289"> </a>
<a name="ln290"> </a>
<a name="ln291">int32_t sys_circle(uint32_t hexColor, uint64_t topLeftX, uint64_t topLeftY, uint64_t diameter){</a>
<a name="ln292">	drawCircle(hexColor, topLeftX, topLeftY, diameter);</a>
<a name="ln293">	return 0;</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">int32_t sys_rectangle(uint32_t color, uint64_t width_pixels, uint64_t height_pixels, uint64_t initial_pos_x, uint64_t initial_pos_y){</a>
<a name="ln297">	drawRectangle(color, width_pixels, height_pixels, initial_pos_x, initial_pos_y);</a>
<a name="ln298">	return 0;</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">int32_t sys_fill_video_memory(uint32_t hexColor) {</a>
<a name="ln302">	fillVideoMemory(hexColor);</a>
<a name="ln303">	return 0;</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">// ==================================================================</a>
<a name="ln307">// Custom exec system call</a>
<a name="ln308">// ==================================================================</a>
<a name="ln309"> </a>
<a name="ln310">int32_t sys_exec(int32_t (*fnPtr)(void)) {</a>
<a name="ln311">	clear();</a>
<a name="ln312"> </a>
<a name="ln313">	uint8_t fontSize = getFontSize(); 					// preserve font size</a>
<a name="ln314">	uint32_t text_color = getTextColor();				// preserve text color</a>
<a name="ln315">	uint32_t background_color = getBackgroundColor();	// preserve background color</a>
<a name="ln316">	</a>
<a name="ln317">	SpecialKeyHandler map[ F12_KEY - ESCAPE_KEY + 1 ] = {0};</a>
<a name="ln318">	clearKeyFnMapNonKernel(map); // avoid &quot;&quot;&quot;processes/threads/apps&quot;&quot;&quot; registering keys across each other over time. reset the map every time</a>
<a name="ln319">	</a>
<a name="ln320">	int32_t aux = fnPtr();</a>
<a name="ln321"> </a>
<a name="ln322">	restoreKeyFnMapNonKernel(map);</a>
<a name="ln323">	setFontSize(fontSize);</a>
<a name="ln324">	setTextColor(text_color);</a>
<a name="ln325">	setBackgroundColor(background_color);</a>
<a name="ln326"> </a>
<a name="ln327">	clear();</a>
<a name="ln328">	return aux;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">// ==================================================================</a>
<a name="ln332">// Custom keyboard system calls</a>
<a name="ln333">// ==================================================================</a>
<a name="ln334"> </a>
<a name="ln335">int32_t sys_register_key(uint8_t scancode, SpecialKeyHandler fn){</a>
<a name="ln336">	registerSpecialKey(scancode, fn, 0);</a>
<a name="ln337">	return 0;</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340">// ==================================================================</a>
<a name="ln341">// Sleep system calls</a>
<a name="ln342">// ==================================================================</a>
<a name="ln343">int32_t sys_sleep_milis(uint32_t milis) {</a>
<a name="ln344">	sleepTicks( (milis * SECONDS_TO_TICKS) / 1000 );</a>
<a name="ln345">	return 0;</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">// ==================================================================</a>
<a name="ln349">// Register snapshot system calls</a>
<a name="ln350">// ==================================================================</a>
<a name="ln351">int32_t sys_get_register_snapshot(int64_t * registers) {</a>
<a name="ln352">	if (register_snapshot_taken == 0) return 0;  </a>
<a name="ln353"> </a>
<a name="ln354">	uint8_t i = 0;</a>
<a name="ln355">	</a>
<a name="ln356">	while (i &lt; 18) {</a>
<a name="ln357">		*(registers++) = register_snapshot[i++];</a>
<a name="ln358">	}</a>
<a name="ln359"> </a>
<a name="ln360">	return 1;</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">int32_t sys_get_character_without_display(void) {</a>
<a name="ln364">	return getKeyboardCharacter(0);</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">// ==================================================================</a>
<a name="ln368">// Memory management system calls</a>
<a name="ln369">// ==================================================================</a>
<a name="ln370"> </a>
<a name="ln371">void * sys_malloc(int size) {</a>
<a name="ln372">	return myMalloc(size);</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">int32_t sys_free(void * ptr) {</a>
<a name="ln376">	if (!isValidHeapPtr(ptr)) {</a>
<a name="ln377">		return 0;</a>
<a name="ln378">	}</a>
<a name="ln379">	myFree(ptr);</a>
<a name="ln380">	return 1;</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">int32_t sys_memstats(int * total, int * used, int * available) {</a>
<a name="ln384">	memstats(total, used, available);</a>
<a name="ln385">	return 0;</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388">// ==================================================================</a>
<a name="ln389">// Process management system calls</a>
<a name="ln390">// ==================================================================</a>
<a name="ln391"> </a>
<a name="ln392">int32_t sys_getpid(void) {</a>
<a name="ln393">	Process * currentProcess = getCurrentProcess();</a>
<a name="ln394">	if (currentProcess == NULL) {</a>
<a name="ln395">		return -1;</a>
<a name="ln396">	}</a>
<a name="ln397">	return currentProcess-&gt;pid;</a>
<a name="ln398">}</a>
<a name="ln399">int32_t sys_create_process(void * function, int argc, char ** argv, uint8_t is_background) {</a>
<a name="ln400">	Process * parent = getCurrentProcess();</a>
<a name="ln401">	int priority = MID_PRIORITY;</a>
<a name="ln402">	int parentID = -1;</a>
<a name="ln403"> </a>
<a name="ln404">	if (parent != NULL) {</a>
<a name="ln405">		priority = parent-&gt;priority;</a>
<a name="ln406">		parentID = parent-&gt;pid;</a>
<a name="ln407">	}</a>
<a name="ln408"> </a>
<a name="ln409">	Process * newProcess = createProcess(function, argc, argv, priority, parentID, is_background);</a>
<a name="ln410">	if (newProcess == NULL) {</a>
<a name="ln411">		return -1;</a>
<a name="ln412">	}</a>
<a name="ln413"> </a>
<a name="ln414">	return newProcess-&gt;pid; // Return the PID of the newly created process</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">int32_t sys_unblock(int pid) {</a>
<a name="ln418">	return unblock(pid);</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">int32_t sys_block(int pid) {</a>
<a name="ln422">	return block(pid);</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">int32_t sys_kill(int pid) {</a>
<a name="ln426">	return kill(pid);</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">int32_t sys_ps(ProcessInformation * processInfoTable) {</a>
<a name="ln430">	return ps(processInfoTable);</a>
<a name="ln431">}</a>
<a name="ln432"> </a>
<a name="ln433">int32_t sys_get_process_info(int pid, ProcessInformation *info) {</a>
<a name="ln434">	return getProcessInfo(pid, info);</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">int32_t sys_nice(int pid, int newPriority) {</a>
<a name="ln438">	return nice(pid, newPriority);</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">int32_t sys_wait_pid(int pid) {</a>
<a name="ln442">	return waitPid(pid);</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">int32_t sys_wait_children(void) {</a>
<a name="ln446">	return waitChildren();</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">int32_t sys_yield(void) {</a>
<a name="ln450">	yield();</a>
<a name="ln451">	return 0;</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">// ==================================================================</a>
<a name="ln455">// Semaphore management system calls</a>
<a name="ln456">// ==================================================================</a>
<a name="ln457"> </a>
<a name="ln458">semADT sys_sem_init(const char *name, uint32_t initial_count) {</a>
<a name="ln459">	return semInit(name, initial_count);</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">int32_t sys_sem_post(semADT sem) {</a>
<a name="ln463">	return post(sem);</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">int32_t sys_sem_wait(semADT sem) {</a>
<a name="ln467">	return wait(sem);</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">int32_t sys_sem_destroy(semADT sem) {</a>
<a name="ln471">	semDestroy(sem);</a>
<a name="ln472">	return 0;</a>
<a name="ln473">}</a>
<a name="ln474">// =========================================================</a>
</code></pre>
<div class="balloon" rel="159"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v739/" target="_blank">V739</a> EOF should not be compared with a value of the 'char' type. Consider using the 'int' type.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>