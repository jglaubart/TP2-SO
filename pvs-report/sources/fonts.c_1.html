<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fonts.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/**</a>
<a name="ln5"> * Note: Certain functions within this file are HOT PATHS.</a>
<a name="ln6"> * They have been optimized as best as possible.</a>
<a name="ln7"> * </a>
<a name="ln8"> * This file is excluded from the main compilation rules, and is always compiled with -O3 (regardless of the main compilation rules).</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;fonts.h&gt;</a>
<a name="ln12">#include &lt;keyboard.h&gt;</a>
<a name="ln13">#include &lt;video.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">/* </a>
<a name="ln16">    Note: An attempt was made to use the Linux kernel's Solarize.12x29.psf (https://wiki.osdev.org/PC_Screen_Font). Now only the pain remains.</a>
<a name="ln17">    The Makefile recipe is left here in case an(other) insane attempt at porting it is made. </a>
<a name="ln18"> </a>
<a name="ln19">    For the time being a simpler bitmapped font embedded into a header file is used.</a>
<a name="ln20">    Note: Symbol table entries on Solarize are: </a>
<a name="ln21">    - _binary___font_assets_Solarize_12x29_psf_start</a>
<a name="ln22">    - _binary___font_assets_Solarize_12x29_psf_end</a>
<a name="ln23">    - _binary___font_assets_Solarize_12x29_psf_size</a>
<a name="ln24"> </a>
<a name="ln25">    NOT the same as the ones listed on https://wiki.osdev.org/PC_Screen_Font</a>
<a name="ln26"> </a>
<a name="ln27">    font.o:</a>
<a name="ln28">        objcopy -O elf64-x86-64 -B i386 -I binary ./font_assets/Solarize.12x29.psf font.o</a>
<a name="ln29"> */</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;include/font_basic_8x8.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#define FD_STDIN  0</a>
<a name="ln34">#define FD_STDOUT 1</a>
<a name="ln35">#define FD_STDERR 2</a>
<a name="ln36"> </a>
<a name="ln37">#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))</a>
<a name="ln38"> </a>
<a name="ln39">static uint16_t glyphSizeX = DEFAULT_GLYPH_SIZE_X;</a>
<a name="ln40">static uint16_t glyphSizeY = DEFAULT_GLYPH_SIZE_Y;</a>
<a name="ln41">static uint16_t fontSize = 1;</a>
<a name="ln42"> </a>
<a name="ln43">static char * bitmap = (char *) font8x8_basic;</a>
<a name="ln44"> </a>
<a name="ln45">static int32_t xBufferPosition;</a>
<a name="ln46">static int32_t yBufferPosition;</a>
<a name="ln47"> </a>
<a name="ln48">static uint16_t maxGlyphSizeYOnLine = DEFAULT_GLYPH_SIZE_Y;</a>
<a name="ln49"> </a>
<a name="ln50">static uint8_t dirty_line;</a>
<a name="ln51"> </a>
<a name="ln52">static uint32_t text_color = DEFAULT_TEXT_COLOR;</a>
<a name="ln53">static uint32_t background_color = DEFAULT_BACKGROUND_COLOR;</a>
<a name="ln54">static uint8_t file_descriptor = FD_STDOUT;</a>
<a name="ln55"> </a>
<a name="ln56">void setTextColor(uint32_t color) {</a>
<a name="ln57">    text_color = color;</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">void setBackgroundColor(uint32_t color) {</a>
<a name="ln61">    background_color = color;</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">uint32_t getTextColor(void) {</a>
<a name="ln65">    return text_color;</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">uint32_t getBackgroundColor(void) {</a>
<a name="ln69">    return background_color;</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">uint16_t getXBufferPosition(void) {</a>
<a name="ln73">    return xBufferPosition;</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">static char buffer[64] = { '0' };</a>
<a name="ln77"> </a>
<a name="ln78">static inline void renderFromBitmap(char * bitmap, uint64_t xBase, uint64_t yBase);</a>
<a name="ln79">static inline void renderAscii(char ascii, uint64_t x, uint64_t y);</a>
<a name="ln80"> </a>
<a name="ln81">void showCursor(void);</a>
<a name="ln82">void hideCursor(void);</a>
<a name="ln83">static void scrollBufferPositionIfNeeded(void);</a>
<a name="ln84">void clearPreviousCharacter(void);</a>
<a name="ln85"> </a>
<a name="ln86">static uint32_t uintToBase(uint64_t value, char * buffer, uint32_t base);</a>
<a name="ln87">static void printBase(uint64_t value, uint32_t base);</a>
<a name="ln88">static inline int64_t strlen(const char * str);</a>
<a name="ln89"> </a>
<a name="ln90">// * Uses inline to avoid stack frames on hot paths *</a>
<a name="ln91">static inline void renderFromBitmap(char * bitmap, uint64_t xBase, uint64_t yBase) {</a>
<a name="ln92">    int xs, xo;</a>
<a name="ln93">    for (int x = 0; x &lt; glyphSizeX * fontSize; x++) {</a>
<a name="ln94">        xs = xBase + x;</a>
<a name="ln95">        xo = x / fontSize;</a>
<a name="ln96">        for (int y = 0; y &lt; glyphSizeY * fontSize; y++) {</a>
<a name="ln97">            // Read into char * slice and mask</a>
<a name="ln98">            putPixel(*(bitmap + (y / fontSize)) &amp; (1 &lt;&lt; xo) ? text_color : background_color, xs, yBase + y);</a>
<a name="ln99">        }</a>
<a name="ln100">    }</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">// * Uses inline to avoid stack frames on hot paths *</a>
<a name="ln104">// `x` and `y` are the TOP LEFT corner positions</a>
<a name="ln105">static inline void renderAscii(char ascii, uint64_t x, uint64_t y) {</a>
<a name="ln106">    if (ascii &lt; 128) {</a>
<a name="ln107">        // The function only takes in a slice of the whole matrix</a>
<a name="ln108">        renderFromBitmap(bitmap + (ascii * glyphSizeY), x, y);</a>
<a name="ln109">    }</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">static void scrollBufferPositionIfNeeded(void) {</a>
<a name="ln113">    if (yBufferPosition + glyphSizeY * fontSize &gt; getWindowHeight()) {</a>
<a name="ln114">        scrollVideoMemoryUp(glyphSizeY * fontSize, DEFAULT_BACKGROUND_COLOR);</a>
<a name="ln115">        yBufferPosition -= glyphSizeY * fontSize;</a>
<a name="ln116">    }</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">// `ascii` ASCII character to print (0-127)</a>
<a name="ln120">void putChar(char ascii) {</a>
<a name="ln121">    dirty_line = 1;</a>
<a name="ln122">    switch (ascii){</a>
<a name="ln123">        case NEW_LINE_CHAR:</a>
<a name="ln124">            hideCursor();</a>
<a name="ln125">            newLine();</a>
<a name="ln126">            break;</a>
<a name="ln127">        case '\b':</a>
<a name="ln128">            clearPreviousCharacter();</a>
<a name="ln129">            break;</a>
<a name="ln130">        case CARRIAGE_RETURN_CHAR:</a>
<a name="ln131">            hideCursor();</a>
<a name="ln132">            while (xBufferPosition &gt; 0) {</a>
<a name="ln133">                retractPosition();</a>
<a name="ln134">            }</a>
<a name="ln135">            break;</a>
<a name="ln136">        case TABULATOR_CHAR:</a>
<a name="ln137">            do {</a>
<a name="ln138">                putChar(' ');</a>
<a name="ln139">            } while(xBufferPosition % (TAB_SIZE * glyphSizeX * fontSize) != 0);</a>
<a name="ln140">            break;</a>
<a name="ln141">        default:</a>
<a name="ln142">            if (xBufferPosition + glyphSizeX * fontSize &gt; getWindowWidth()) {</a>
<a name="ln143">                newLine();</a>
<a name="ln144">            }</a>
<a name="ln145"> </a>
<a name="ln146">            renderAscii(ascii, xBufferPosition, yBufferPosition);</a>
<a name="ln147">            xBufferPosition += glyphSizeX * fontSize;</a>
<a name="ln148">            break;</a>
<a name="ln149">    }</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">int32_t printToFd(int32_t fd, const char * string, int32_t count) {</a>
<a name="ln153">    if (fd != file_descriptor) {</a>
<a name="ln154">        switch (fd) {</a>
<a name="ln155">            case FD_STDIN:</a>
<a name="ln156">                int i = 0;</a>
<a name="ln157">                for ( ; i &lt; count; i++ ) {</a>
<a name="ln158">                    addCharToBuffer(string[i], 1);</a>
<a name="ln159">                }</a>
<a name="ln160">                return i;</a>
<a name="ln161">            case FD_STDOUT:</a>
<a name="ln162">                text_color = DEFAULT_TEXT_COLOR;</a>
<a name="ln163">                background_color = DEFAULT_BACKGROUND_COLOR;</a>
<a name="ln164">                file_descriptor = fd;</a>
<a name="ln165">                break;</a>
<a name="ln166">            case FD_STDERR:</a>
<a name="ln167">                text_color = DEFAULT_ERROR_COLOR;</a>
<a name="ln168">                background_color = DEFAULT_BACKGROUND_COLOR;</a>
<a name="ln169">                file_descriptor = fd;</a>
<a name="ln170">                break;</a>
<a name="ln171">            default:</a>
<a name="ln172">        }</a>
<a name="ln173">    }</a>
<a name="ln174"> </a>
<a name="ln175">    int i = 0;</a>
<a name="ln176">    for ( ; i &lt; count; i++ ) {</a>
<a name="ln177">        putChar(string[i]);</a>
<a name="ln178">    }</a>
<a name="ln179"> </a>
<a name="ln180">    return i;</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">// Prints `string` Null terminated string to `STDOUT`</a>
<a name="ln184">void print(const char * string) {</a>
<a name="ln185">    printToFd(FD_STDOUT, string, strlen(string));</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">// Jumps to the next line, does not print an empty line</a>
<a name="ln189">void newLine(void) {</a>
<a name="ln190">    dirty_line = 0;</a>
<a name="ln191">    yBufferPosition += maxGlyphSizeYOnLine;</a>
<a name="ln192">    xBufferPosition = 0;</a>
<a name="ln193">    maxGlyphSizeYOnLine = fontSize * glyphSizeY;</a>
<a name="ln194">    scrollBufferPositionIfNeeded();</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">void printDec(uint64_t value) {</a>
<a name="ln198">    printBase(value, 10);</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">void printHex(uint64_t value) {</a>
<a name="ln202">    printBase(value, 16);</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">void printBin(uint64_t value) {</a>
<a name="ln206">    printBase(value, 2);</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">void clear(void) {</a>
<a name="ln210">    fillVideoMemory(DEFAULT_BACKGROUND_COLOR);</a>
<a name="ln211">    xBufferPosition = 0;</a>
<a name="ln212">    yBufferPosition = 0;</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">void retractPosition() {</a>
<a name="ln216">    uint16_t window_width = getWindowWidth();</a>
<a name="ln217">    </a>
<a name="ln218">    if(xBufferPosition == 0){</a>
<a name="ln219">        yBufferPosition -= glyphSizeY * fontSize;</a>
<a name="ln220">        if (yBufferPosition &lt; 0) {</a>
<a name="ln221">            yBufferPosition = 0;</a>
<a name="ln222">            return;</a>
<a name="ln223">        }</a>
<a name="ln224">        xBufferPosition = window_width - (window_width % (fontSize * glyphSizeX));</a>
<a name="ln225">    }</a>
<a name="ln226"> </a>
<a name="ln227">    xBufferPosition -= glyphSizeX * fontSize;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">void clearPreviousCharacter(void){</a>
<a name="ln231">    hideCursor();</a>
<a name="ln232">    retractPosition();</a>
<a name="ln233">    putChar(' ');</a>
<a name="ln234">    retractPosition();</a>
<a name="ln235">    showCursor();</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">void showCursor(void) {</a>
<a name="ln239">    putChar('|');</a>
<a name="ln240">    retractPosition();</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243">void hideCursor(void) {</a>
<a name="ln244">    putChar(' ');</a>
<a name="ln245">    retractPosition();</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">uint8_t increaseFontSize(void) {</a>
<a name="ln249">    fontSize = fontSize &gt; 9 ? fontSize : fontSize + 1;</a>
<a name="ln250">    maxGlyphSizeYOnLine =  dirty_line == 1 ? MAX(maxGlyphSizeYOnLine, glyphSizeY * fontSize) : (glyphSizeY * fontSize);</a>
<a name="ln251">    scrollBufferPositionIfNeeded();</a>
<a name="ln252">    return fontSize;</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">uint8_t decreaseFontSize(void) {</a>
<a name="ln256">    fontSize = fontSize &lt;= 1 ? fontSize : fontSize - 1;</a>
<a name="ln257">    maxGlyphSizeYOnLine = dirty_line == 1 ? MAX(maxGlyphSizeYOnLine, glyphSizeY * fontSize) : (glyphSizeY * fontSize);</a>
<a name="ln258">    return fontSize;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">uint8_t setFontSize(int8_t size) {</a>
<a name="ln262">    fontSize = (size &lt; 1 ? 1 : size &gt; 10 ? 10 : size);</a>
<a name="ln263">    maxGlyphSizeYOnLine = dirty_line == 1 ? MAX(maxGlyphSizeYOnLine, glyphSizeY * fontSize) : (glyphSizeY * fontSize);</a>
<a name="ln264">    return fontSize;</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">uint8_t getFontSize(void) {</a>
<a name="ln268">    return fontSize;</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">static void printBase(uint64_t value, uint32_t base) {</a>
<a name="ln272">    uintToBase(value, buffer, base);</a>
<a name="ln273">    print(buffer);</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">static uint32_t uintToBase(uint64_t value, char * buffer, uint32_t base) {</a>
<a name="ln277">	char *p = buffer;</a>
<a name="ln278">	char *p1, *p2;</a>
<a name="ln279">	uint32_t digits = 0;</a>
<a name="ln280"> </a>
<a name="ln281">	// Calculate characters for each digit</a>
<a name="ln282">	do</a>
<a name="ln283">	{</a>
<a name="ln284">		uint32_t remainder = value % base;</a>
<a name="ln285">		*p++ = (remainder &lt; 10) ? remainder + '0' : remainder + 'A' - 10;</a>
<a name="ln286">		digits++;</a>
<a name="ln287">	}</a>
<a name="ln288">	while (value /= base);</a>
<a name="ln289"> </a>
<a name="ln290">	// Terminate string in buffer.</a>
<a name="ln291">    // @todo Could this overflow?</a>
<a name="ln292">	*p = 0;</a>
<a name="ln293"> </a>
<a name="ln294">	// Reverse string in buffer.</a>
<a name="ln295">	p1 = buffer;</a>
<a name="ln296">	p2 = p - 1;</a>
<a name="ln297">	while (p1 &lt; p2)</a>
<a name="ln298">	{</a>
<a name="ln299">		char tmp = *p1;</a>
<a name="ln300">		*p1 = *p2;</a>
<a name="ln301">		*p2 = tmp;</a>
<a name="ln302">		p1++;</a>
<a name="ln303">		p2--;</a>
<a name="ln304">	}</a>
<a name="ln305"> </a>
<a name="ln306">	return digits;</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">static inline int64_t strlen(const char * str) {</a>
<a name="ln310">    int64_t length = 0;</a>
<a name="ln311">    while (str[length] != 0) {</a>
<a name="ln312">        length++;</a>
<a name="ln313">    }</a>
<a name="ln314">    return length;</a>
<a name="ln315">}</a>
</code></pre>
<div class="balloon" rel="76"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1009/" target="_blank">V1009</a> Check the array initialization. Only the first element is initialized explicitly. The rest elements are initialized with zeros.</p></div>
<div class="balloon" rel="106"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'ascii &lt; 128' is always true. The value range of char type: [-128, 127].</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>